## 第一性原理拆解：React 状态（State）

### 核心问题：组件如何记住和管理随时间变化的数据？

---

## 一、什么是 State？

```
┌─────────────────────────────────────────────────────────┐
│  State = 组件的"记忆"                                    │
│                                                         │
│  • 组件私有的、可变的数据                                │
│  • 状态改变 → 触发重新渲染                               │
│  • React 将组件看作状态机                                │
└─────────────────────────────────────────────────────────┘
```

### 类组件 vs 函数组件

```jsx
// 类组件
class Counter extends React.Component {
    state = { count: 0 };
    
    increment = () => {
        this.setState({ count: this.state.count + 1 });
    };
    
    render() {
        return <button onClick={this.increment}>{this.state.count}</button>;
    }
}

// 函数组件 + Hooks
function Counter() {
    const [count, setCount] = useState(0);
    
    return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

---

## 二、State vs Props

| 特性 | State | Props |
|------|-------|-------|
| 来源 | 组件内部声明 | 父组件传入 |
| 可变性 | 可通过 setState/setXxx 修改 | 只读，不能修改 |
| 所有者 | 当前组件 | 父组件 |
| 用途 | 存储可变数据 | 传递数据、回调、children |

```jsx
// Props：父组件传入，不可修改
function Child({ name, onNameChange }) {
    // ❌ 错误：props.name = 'new name';
    // ✅ 正确：通过回调通知父组件
    return <button onClick={() => onNameChange('new name')}>{name}</button>;
}

// State：组件内部，可以修改
function Parent() {
    const [name, setName] = useState('John');
    return <Child name={name} onNameChange={setName} />;
}
```

---

## 三、状态提升（Lifting State Up）

### 核心原则：单一数据源

```
┌─────────────────────────────────────────────────────────┐
│  多个组件需要共享状态时：                                │
│  将状态提升到它们最近的共同父组件                        │
└─────────────────────────────────────────────────────────┘
```

### 经典代码：温度转换器

```jsx
// ❌ 错误：各自管理状态，无法同步
function TemperatureInput({ scale }) {
    const [value, setValue] = useState('');  // 各自独立
    // ...
}

// ✅ 正确：状态提升到父组件
function Calculator() {
    const [temperature, setTemperature] = useState('');
    const [scale, setScale] = useState('c');
    
    const handleCelsiusChange = (value) => {
        setScale('c');
        setTemperature(value);
    };
    
    const handleFahrenheitChange = (value) => {
        setScale('f');
        setTemperature(value);
    };
    
    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
    
    return (
        <div>
            <TemperatureInput 
                scale="c" 
                value={celsius}
                onChange={handleCelsiusChange} 
            />
            <TemperatureInput 
                scale="f" 
                value={fahrenheit}
                onChange={handleFahrenheitChange} 
            />
            <BoilingVerdict celsius={parseFloat(celsius)} />
        </div>
    );
}

function TemperatureInput({ scale, value, onChange }) {
    return (
        <input 
            value={value}
            onChange={e => onChange(e.target.value)}
            placeholder={scale === 'c' ? '摄氏度' : '华氏度'}
        />
    );
}
```

---

## 四、setState 详解（类组件）

### 用法一：对象形式

```jsx
// 浅合并到 state
this.setState({ count: 1 });

// 原 state: { count: 0, name: 'John' }
// 新 state: { count: 1, name: 'John' }  // name 保留
```

### 用法二：函数形式（推荐）

```jsx
// 基于前一个 state 计算新 state
this.setState((prevState, props) => ({
    count: prevState.count + 1
}));

// 适用场景：连续更新
handleClick = () => {
    // ❌ 错误：可能只加 1（批量更新合并）
    this.setState({ count: this.state.count + 1 });
    this.setState({ count: this.state.count + 1 });
    this.setState({ count: this.state.count + 1 });
    
    // ✅ 正确：加 3
    this.setState(prev => ({ count: prev.count + 1 }));
    this.setState(prev => ({ count: prev.count + 1 }));
    this.setState(prev => ({ count: prev.count + 1 }));
};
```

### 用法三：回调函数

```jsx
this.setState(
    { count: this.state.count + 1 },
    () => {
        // 在状态更新且重新渲染后执行
        console.log('Updated:', this.state.count);
    }
);
```

### setState 的异步性

```jsx
handleClick = () => {
    console.log('Before:', this.state.count);  // 0
    this.setState({ count: this.state.count + 1 });
    console.log('After:', this.state.count);   // 还是 0！
};

// 原因：setState 是异步的（批量更新优化）
// 解决：使用回调或 componentDidUpdate
```

---

## 五、useState 详解（函数组件）

### 基本用法

```jsx
const [state, setState] = useState(initialValue);

// 示例
const [count, setCount] = useState(0);
const [user, setUser] = useState({ name: '', age: 0 });
const [items, setItems] = useState([]);
```

### 惰性初始化

```jsx
// ❌ 每次渲染都执行
const [state, setState] = useState(expensiveComputation());

// ✅ 只在首次渲染执行
const [state, setState] = useState(() => expensiveComputation());
```

### 函数式更新

```jsx
// 基于前一个值更新
setCount(prevCount => prevCount + 1);

// 连续更新
const handleTripleIncrement = () => {
    setCount(c => c + 1);
    setCount(c => c + 1);
    setCount(c => c + 1);  // 最终加 3
};
```

### 注意：useState 不会自动合并

```jsx
// 类组件：自动浅合并
this.setState({ name: 'Jane' });  // 其他属性保留

// 函数组件：完全替换
const [user, setUser] = useState({ name: 'John', age: 20 });

// ❌ 错误：丢失 age
setUser({ name: 'Jane' });

// ✅ 正确：手动合并
setUser(prev => ({ ...prev, name: 'Jane' }));
```

---

## 六、经典面试代码

### 1. setState 是同步还是异步？

```jsx
class Example extends React.Component {
    state = { count: 0 };
    
    componentDidMount() {
        // React 事件中：异步（批量更新）
        this.setState({ count: this.state.count + 1 });
        console.log(this.state.count);  // 0
        
        this.setState({ count: this.state.count + 1 });
        console.log(this.state.count);  // 0
        
        // setTimeout 中：React 18 之前同步，React 18 后异步
        setTimeout(() => {
            this.setState({ count: this.state.count + 1 });
            console.log(this.state.count);  // React 18: 仍是批量
        }, 0);
        
        // 原生事件中：React 18 之前同步
        document.getElementById('btn').addEventListener('click', () => {
            this.setState({ count: this.state.count + 1 });
            console.log(this.state.count);  // React 18: 仍是批量
        });
    }
}

// React 18 自动批量更新：所有更新都是异步批量的
// 如需同步更新：使用 flushSync
import { flushSync } from 'react-dom';

flushSync(() => {
    setCount(c => c + 1);
});
console.log(count);  // 更新后的值
```

### 2. 动态状态名称

```jsx
// ES6 计算属性名
const [form, setForm] = useState({
    username: '',
    password: '',
    email: ''
});

const handleChange = (e) => {
    const { name, value } = e.target;
    setForm(prev => ({
        ...prev,
        [name]: value  // 动态属性名
    }));
};

return (
    <form>
        <input name="username" value={form.username} onChange={handleChange} />
        <input name="password" value={form.password} onChange={handleChange} />
        <input name="email" value={form.email} onChange={handleChange} />
    </form>
);
```

### 3. 避免不必要的更新

```jsx
// 类组件：在 setState 中返回 null
getData = (data) => {
    const { time } = data;
    this.setState(state => {
        // 值相同时返回 null，不触发更新
        return state.time === time ? null : { time };
    });
};

// 函数组件：React 自动优化（Object.is 比较）
const [count, setCount] = useState(0);
setCount(0);  // 值相同，不会重新渲染
```

### 4. 对象类型 State 优化

```jsx
// ❌ 问题：嵌套太深，更新麻烦
const [state, setState] = useState({
    user: {
        profile: {
            name: 'John',
            address: {
                city: 'Beijing'
            }
        }
    }
});

// 更新 city 需要：
setState(prev => ({
    ...prev,
    user: {
        ...prev.user,
        profile: {
            ...prev.user.profile,
            address: {
                ...prev.user.profile.address,
                city: 'Shanghai'
            }
        }
    }
}));

// ✅ 解决方案 1：扁平化 state
const [name, setName] = useState('John');
const [city, setCity] = useState('Beijing');

// ✅ 解决方案 2：使用 Immer
import { useImmer } from 'use-immer';

const [state, updateState] = useImmer({
    user: { profile: { name: 'John', address: { city: 'Beijing' } } }
});

updateState(draft => {
    draft.user.profile.address.city = 'Shanghai';
});

// ✅ 解决方案 3：拆分到子组件
function Address({ address, onUpdate }) {
    // 只关心 address
}
```

### 5. setState vs replaceState

```jsx
// setState：浅合并
this.state = { a: 1, b: 2 };
this.setState({ a: 10 });
// 结果：{ a: 10, b: 2 }

// replaceState（已废弃）：完全替换
this.replaceState({ a: 10 });
// 结果：{ a: 10 }  // b 丢失

// 现代等价写法
this.setState({ a: 10, b: undefined });
// 或
this.setState(prev => ({ a: 10 }));  // 但这样不会删除 b
```

### 6. 判断什么应该作为 State

```jsx
// 判断流程：
// 1. 是否从 props 传入？→ 不是 state
// 2. 是否始终不变？→ 不是 state
// 3. 是否可以从其他 state/props 计算？→ 不是 state
// 4. 以上都不是？→ 是 state

// 示例：搜索过滤列表
function ProductTable({ products }) {
    const [filterText, setFilterText] = useState('');
    const [inStockOnly, setInStockOnly] = useState(false);
    
    // ❌ 不应该是 state：可以从 products + filterText 计算
    // const [filteredProducts, setFilteredProducts] = useState([]);
    
    // ✅ 派生数据：直接计算
    const filteredProducts = products.filter(product => {
        if (inStockOnly && !product.stocked) return false;
        if (!product.name.includes(filterText)) return false;
        return true;
    });
    
    return <div>{/* ... */}</div>;
}
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    React State 核心要点                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  State 本质                                                     │
│  ├── 组件的私有可变数据                                         │
│  ├── 状态改变触发重新渲染                                       │
│  └── 类组件用 setState，函数组件用 useState                     │
│                                                                 │
│  State vs Props                                                 │
│  ├── State：组件内部，可变                                      │
│  └── Props：父组件传入，只读                                    │
│                                                                 │
│  状态提升                                                       │
│  └── 共享状态提升到最近共同父组件，保持单一数据源               │
│                                                                 │
│  setState 特性                                                  │
│  ├── 异步批量更新（React 18 全部异步）                          │
│  ├── 对象形式：浅合并                                           │
│  ├── 函数形式：基于前值更新（推荐）                             │
│  └── 回调：更新后执行                                           │
│                                                                 │
│  useState 注意点                                                │
│  ├── 不自动合并，需手动展开                                     │
│  ├── 惰性初始化：传函数                                         │
│  └── 函数式更新：连续更新必用                                   │
│                                                                 │
│  优化建议                                                       │
│  ├── 避免深层嵌套 state                                         │
│  ├── 派生数据不要存 state                                       │
│  └── 使用 Immer 简化不可变更新                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心记忆：State 是组件的记忆，setState 是异步批量的，函数式更新最可靠，共享状态要提升。**