我来认真拆解这份 React 通信章节的内容，从第一性原理出发进行深度总结。

## 核心问题：组件间如何共享数据？

React 的本质是**组件化**，而组件化必然带来一个问题：独立的组件如何共享数据？这就是"通信"要解决的根本问题。

---

## 一、Props：最基础的通信方式

**第一性原理**：React 组件本质是函数，props 就是函数参数。

```jsx
// 父 → 子：传递数据
function Parent() {
  const [count, setCount] = useState(0);
  return <Child count={count} onAdd={() => setCount(c => c + 1)} />;
}

// 子 → 父：通过回调函数
function Child({ count, onAdd }) {
  return <button onClick={onAdd}>Count: {count}</button>;
}
```

**为什么是单向数据流？**

这是设计选择，不是技术限制。单向流的好处是**可预测性**：
- 状态只属于定义它的组件
- 数据变化只能影响"下游"组件
- Bug 排查时，沿着组件树向上找就能定位问题源

---

## 二、Refs：绕过数据流的"逃生舱"

**第一性原理**：有时需要直接操作 DOM 或组件实例，而不是通过数据驱动。

```jsx
// 经典场景：管理焦点
function TextInputWithFocus() {
  const inputRef = useRef(null);
  
  useEffect(() => {
    inputRef.current.focus(); // 直接操作 DOM
  }, []);
  
  return <input ref={inputRef} />;
}
```

**Ref 转发**：让父组件能访问子组件内部的 DOM

```jsx
// 子组件暴露内部 DOM
const FancyInput = forwardRef((props, ref) => (
  <input ref={ref} className="fancy" {...props} />
));

// 父组件使用
function Parent() {
  const inputRef = useRef(null);
  return <FancyInput ref={inputRef} />;
}
```

---

## 三、Context：解决"props 钻井"问题

**第一性原理**：当数据需要跨越多层组件时，逐层传递 props 太繁琐。Context 提供"隧道"直达。

```jsx
// 1. 创建 Context
const ThemeContext = createContext('light');

// 2. 顶层提供
function App() {
  const [theme, setTheme] = useState('dark');
  return (
    <ThemeContext.Provider value={theme}>
      <DeepNestedComponent />
    </ThemeContext.Provider>
  );
}

// 3. 任意深度消费
function DeepNestedComponent() {
  const theme = useContext(ThemeContext);
  return <div className={theme}>Hello</div>;
}
```

**Context 的代价**：Provider 的 value 变化时，所有消费者都会重新渲染。

**优化策略**：

```jsx
// 策略1：拆分 Context，分离变化频率不同的数据
const UserContext = createContext(null);    // 很少变
const ThemeContext = createContext('light'); // 偶尔变

// 策略2：用 memo 阻断不必要的渲染
const ExpensiveComponent = memo(({ data }) => {
  // 只有 data 变化才重新渲染
});

// 策略3：将 value 提升到 state，避免每次渲染创建新对象
function Provider({ children }) {
  const [state, setState] = useState({ user: null, theme: 'light' });
  // ❌ 错误：value={{ user, theme }} 每次都是新对象
  // ✅ 正确：value={state}
  return <AppContext.Provider value={state}>{children}</AppContext.Provider>;
}
```

---

## 四、事件总线：组件树外的通信

**第一性原理**：发布-订阅模式，解耦生产者和消费者。

```jsx
// 极简实现
class EventBus {
  constructor() {
    this.listeners = {};
  }
  
  on(event, callback) {
    (this.listeners[event] ||= []).push(callback);
    return () => this.off(event, callback); // 返回取消函数
  }
  
  off(event, callback) {
    this.listeners[event] = this.listeners[event]?.filter(cb => cb !== callback);
  }
  
  emit(event, ...args) {
    this.listeners[event]?.forEach(cb => cb(...args));
  }
}

// 使用
const bus = new EventBus();

function ComponentA() {
  return <button onClick={() => bus.emit('message', 'Hello')}>Send</button>;
}

function ComponentB() {
  const [msg, setMsg] = useState('');
  useEffect(() => bus.on('message', setMsg), []);
  return <div>{msg}</div>;
}
```

---

## 五、状态管理库：规模化解决方案

当应用复杂度上升，需要更系统的方案。

**Redux 核心思想**：
```jsx
// 单一数据源 + 纯函数更新
const reducer = (state = { count: 0 }, action) => {
  switch (action.type) {
    case 'INCREMENT': return { count: state.count + 1 };
    default: return state;
  }
};

// 使用
const store = createStore(reducer);
store.dispatch({ type: 'INCREMENT' });
```

**现代轻量方案 - Zustand**：
```jsx
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

function Counter() {
  const { count, increment } = useStore();
  return <button onClick={increment}>{count}</button>;
}
```

---

## 面试高频考点总结

| 问题 | 关键答题点 |
|------|-----------|
| 父子通信方式 | props 下传，回调上传 |
| 为什么单向数据流 | 可预测、易调试、状态归属清晰 |
| Context 什么时候用 | 跨层级共享（主题、用户、语言） |
| Context 性能问题 | value 变化导致所有消费者重渲染 |
| Context 优化 | 拆分 Context、memo、避免对象字面量 |
| Ref 转发场景 | 高阶组件、表单库、焦点管理 |

**一句话总结**：React 通信的本质是在"组件隔离"与"数据共享"之间找平衡，不同方案适用于不同的数据流动范围和频率。