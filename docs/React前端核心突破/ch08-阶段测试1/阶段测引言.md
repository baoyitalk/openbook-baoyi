我来系统拆解这份阶段测试和生命周期章节，给出完整的面试答案。

---

# 阶段测试 I - 简答题完整解析

## 1. React 和 Vue 的共同点

```
┌────────────────────────────────────────────────────────────┐
│                    React vs Vue 共同点                      │
├────────────────────────────────────────────────────────────┤
│  ✓ 都使用 Virtual DOM 提高渲染效率                          │
│  ✓ 都是组件化开发思想                                       │
│  ✓ 都是单向数据流（Vue 的 v-model 是语法糖）                 │
│  ✓ 都支持服务端渲染 (SSR)                                   │
│  ✓ 都有自己的状态管理方案 (Redux/Vuex/Pinia)                │
│  ✓ 都有路由解决方案 (React Router / Vue Router)             │
└────────────────────────────────────────────────────────────┘
```

---

## 2. 为什么 JSX 中 class 变成了 className？

**根本原因**：JSX 最终被编译成 JavaScript 对象，而 `class` 是 JavaScript 的保留关键字。

```jsx
// JSX 写法
<div className="container">Hello</div>

// 编译后的 JavaScript
React.createElement('div', { className: 'container' }, 'Hello');

// 如果用 class，会与 ES6 class 关键字冲突
class MyComponent {}  // 这里的 class 是关键字
```

---

## 3. 受控组件 vs 非受控组件

```jsx
// 受控组件：React 控制表单状态
function Controlled() {
  const [value, setValue] = useState('');
  return (
    <input 
      value={value}                           // React 控制值
      onChange={e => setValue(e.target.value)} // 每次输入都更新
    />
  );
}

// 非受控组件：DOM 自己管理状态
function Uncontrolled() {
  const inputRef = useRef(null);
  const handleSubmit = () => {
    console.log(inputRef.current.value);  // 提交时才读取
  };
  return <input ref={inputRef} defaultValue="初始值" />;
}
```

**答案**：非受控组件无需被 React 组件包裹，它使用 `ref` 和 `defaultValue`，让 DOM 自己管理状态。

---

## 4. PureComponent vs Component

```jsx
// Component：每次父组件渲染都会重新渲染
class NormalChild extends React.Component {
  render() {
    console.log('NormalChild 渲染');
    return <div>{this.props.name}</div>;
  }
}

// PureComponent：自动浅比较 props 和 state
class PureChild extends React.PureComponent {
  render() {
    console.log('PureChild 渲染');  // props 没变就不渲染
    return <div>{this.props.name}</div>;
  }
}

// 函数组件等价写法
const MemoChild = React.memo(function Child({ name }) {
  return <div>{name}</div>;
});
```

**核心区别**：PureComponent 在 `shouldComponentUpdate` 中自动进行 props 和 state 的**浅比较**。

---

## 5. 展示组件 vs 容器组件

```
┌─────────────────────────────────────────────────────────────┐
│                    组件职责分离                              │
├────────────────────────┬────────────────────────────────────┤
│      展示组件           │           容器组件                 │
├────────────────────────┼────────────────────────────────────┤
│  关注"长什么样"         │  关注"数据怎么来"                  │
│  通过 props 接收数据     │  调用 API、管理状态                │
│  很少有自己的 state     │  为展示组件提供数据和回调           │
│  纯 UI，易复用          │  业务逻辑集中                      │
└────────────────────────┴────────────────────────────────────┘
```

```jsx
// 展示组件：只负责 UI
function UserList({ users, onSelect }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id} onClick={() => onSelect(user)}>
          {user.name}
        </li>
      ))}
    </ul>
  );
}

// 容器组件：负责数据和逻辑
function UserListContainer() {
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    fetch('/api/users').then(r => r.json()).then(setUsers);
  }, []);
  
  const handleSelect = (user) => {
    console.log('选中', user);
  };
  
  return <UserList users={users} onSelect={handleSelect} />;
}
```

---

## 6. 设计 React 组件的三个步骤

```
┌─────────────────────────────────────────────────────────────┐
│                   组件设计三步法                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Step 1: 构建静态版本                                        │
│  ├── 先用硬编码数据把 UI 搭出来                              │
│  └── 不考虑交互，专注结构                                    │
│                                                             │
│  Step 2: 确定 State                                         │
│  ├── 找出最小化的 state                                      │
│  ├── 确定 state 应该放在哪个组件                             │
│  └── 原则：state 放在需要它的组件的最近公共祖先               │
│                                                             │
│  Step 3: 添加交互                                           │
│  ├── 添加事件处理                                           │
│  └── 实现数据流动（子组件通过回调修改父组件 state）          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7. 构建静态版本的步骤

```jsx
// Step 1: 拆分组件层级
/*
  FilterableProductTable
  ├── SearchBar
  └── ProductTable
      ├── ProductCategoryRow
      └── ProductRow
*/

// Step 2: 自顶向下或自底向上构建
// 简单项目：自顶向下
// 复杂项目：自底向上（更容易测试）

// Step 3: 先用 props 传递数据，不用 state
function ProductTable({ products }) {
  return (
    <table>
      {products.map(product => (
        <ProductRow key={product.id} product={product} />
      ))}
    </table>
  );
}
```

---

## 8. setState 的用法

```jsx
class Counter extends React.Component {
  state = { count: 0, name: 'test' };

  handleClick = () => {
    // 用法1：对象形式（适合不依赖之前状态）
    this.setState({ count: 1 });

    // 用法2：函数形式（适合依赖之前状态）⭐推荐
    this.setState(prevState => ({
      count: prevState.count + 1
    }));

    // 用法3：带回调（在更新完成后执行）
    this.setState(
      { count: 10 },
      () => console.log('更新完成', this.state.count)
    );
  };
}

// Hooks 时代
function Counter() {
  const [count, setCount] = useState(0);
  
  // 直接赋值
  setCount(5);
  
  // 函数式更新（推荐）
  setCount(prev => prev + 1);
}
```

---

## 9. 为什么 State 值为 Object 时要用新对象？

**第一性原理**：React 用**引用比较**判断是否需要更新。

```jsx
// ❌ 错误：直接修改对象，引用没变，React 不会更新
const handleClick = () => {
  state.user.name = 'new name';  // 直接修改
  setState(state);               // 引用相同，不触发更新！
};

// ✅ 正确：创建新对象，引用改变
const handleClick = () => {
  setState({
    ...state,
    user: { ...state.user, name: 'new name' }
  });
};

// 更清晰的方式：使用 immer
import { produce } from 'immer';

const handleClick = () => {
  setState(produce(draft => {
    draft.user.name = 'new name';  // 看起来像直接修改
  }));                              // 但 immer 会创建新对象
};
```

---

## 10. PropTypes 静态类型检查

```jsx
import PropTypes from 'prop-types';

function User({ name, age, email, role, onSave }) {
  return <div>{name} - {age}</div>;
}

User.propTypes = {
  name: PropTypes.string.isRequired,      // 必填字符串
  age: PropTypes.number,                   // 可选数字
  email: PropTypes.string,
  role: PropTypes.oneOf(['admin', 'user']), // 枚举值
  onSave: PropTypes.func,                  // 函数
  children: PropTypes.node,                // 可渲染内容
  style: PropTypes.object,
  config: PropTypes.shape({                // 对象结构
    theme: PropTypes.string,
    locale: PropTypes.string
  })
};

User.defaultProps = {
  age: 18,
  role: 'user'
};
```

---

## 11. Refs 适合的场景

```jsx
// 场景1：管理焦点
function SearchForm() {
  const inputRef = useRef(null);
  useEffect(() => inputRef.current.focus(), []);
  return <input ref={inputRef} />;
}

// 场景2：触发动画
function AnimatedBox() {
  const boxRef = useRef(null);
  const animate = () => {
    boxRef.current.classList.add('shake');
  };
  return <div ref={boxRef} onClick={animate}>Click me</div>;
}

// 场景3：集成第三方 DOM 库
function Chart({ data }) {
  const containerRef = useRef(null);
  useEffect(() => {
    const chart = echarts.init(containerRef.current);
    chart.setOption({ /* ... */ });
    return () => chart.dispose();
  }, [data]);
  return <div ref={containerRef} style={{ height: 400 }} />;
}

// 场景4：媒体播放控制
function VideoPlayer() {
  const videoRef = useRef(null);
  return (
    <div>
      <video ref={videoRef} src="movie.mp4" />
      <button onClick={() => videoRef.current.play()}>播放</button>
      <button onClick={() => videoRef.current.pause()}>暂停</button>
    </div>
  );
}
```

---

## 12. 为什么 React 是单向数据流？

```
┌──────────────────────────────────────────────────────────────┐
│                     单向数据流原理                            │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│     State 所有者                                             │
│         │                                                    │
│         │ props（只读）                                       │
│         ▼                                                    │
│     子组件 A ──────────────────────────┐                     │
│         │                              │                     │
│         │ props（只读）                 │ 回调函数            │
│         ▼                              │                     │
│     孙组件 B                           │                     │
│         │                              │                     │
│         └──────── 事件触发 ────────────┘                     │
│                      │                                       │
│                      ▼                                       │
│              修改 State 所有者的状态                          │
│                      │                                       │
│                      ▼                                       │
│              触发重新渲染，新 props 向下传递                   │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

**好处**：
1. **可预测**：知道数据从哪来，到哪去
2. **易调试**：沿着组件树向上就能找到状态源
3. **单一职责**：每个状态只有一个"主人"

---

## 13. 单向绑定 vs 双向绑定

```jsx
// 单向绑定（React 默认）
// 坏处：需要写更多代码
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  
  return (
    <form>
      <input value={name} onChange={e => setName(e.target.value)} />
      <input value={email} onChange={e => setEmail(e.target.value)} />
    </form>
  );
}

// 双向绑定（Vue 的 v-model）
// <input v-model="name">  一行搞定

// 但双向绑定的坏处：
// 1. 数据流向不清晰，难以追踪变化
// 2. 复杂表单中容易产生循环更新
// 3. 隐式行为，不够显式
```

---

## 14. Context 应用场景及副作用

```jsx
// 应用场景：跨层级共享"全局"数据
const ThemeContext = createContext('light');

// 适合：主题、语言、用户信息、路由
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Header />    {/* 不需要接收 theme */}
      <Main />      {/* 不需要接收 theme */}
      <Footer />    {/* 不需要接收 theme */}
    </ThemeContext.Provider>
  );
}

// 副作用：
// 1. 降低组件复用性（组件依赖特定 Context）
// 2. Provider value 变化导致所有消费者重渲染
// 3. 过度使用会使数据流难以追踪
```

---

## 15. 优化不必要渲染的方式

```
┌─────────────────────────────────────────────────────────────┐
│                    渲染优化方式汇总                          │
├─────────────────────────────────────────────────────────────┤
│  1. React.memo / PureComponent    - 浅比较阻止重渲染        │
│  2. useMemo                       - 缓存计算结果            │
│  3. useCallback                   - 稳定函数引用            │
│  4. 状态下沉                       - 把状态移到需要的组件    │
│  5. 状态提升到合适位置              - 避免不必要的传递       │
│  6. 拆分组件                       - 隔离变化区域           │
│  7. 正确使用 key                   - 帮助 React 识别元素    │
│  8. 虚拟列表                       - 只渲染可见区域         │
│  9. 懒加载                         - 按需加载组件           │
│  10. 防抖节流                      - 减少更新频率           │
└─────────────────────────────────────────────────────────────┘
```

---

## 16. 什么是"阻塞渲染"？

```
┌─────────────────────────────────────────────────────────────┐
│                      阻塞渲染                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  传统 Stack Reconciler：                                    │
│                                                             │
│  开始更新 ═══════════════════════════════════════> 完成     │
│     │                                              │        │
│     │←────────── 这段时间不能响应用户 ──────────→│        │
│     │                                              │        │
│  用户点击按钮...等待...等待...等待...终于响应了              │
│                                                             │
│  问题：JS 单线程，长时间执行会阻塞 UI 响应                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 17. Fiber Reconciler 的两个阶段

```
┌─────────────────────────────────────────────────────────────┐
│              Fiber 两阶段渲染                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  阶段1: Render/Reconciliation（可中断 ✓）                   │
│  ├── 遍历 Fiber 树，找出需要更新的节点                       │
│  ├── 调用 render、shouldComponentUpdate 等                  │
│  ├── 构建 workInProgress 树                                 │
│  └── 可以被更高优先级任务打断                                │
│                                                             │
│  阶段2: Commit（不可中断 ✗）                                │
│  ├── 将变更一次性应用到 DOM                                 │
│  ├── 调用 componentDidMount/Update                         │
│  └── 执行 useEffect                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

# 选择题答案速查

| 题目 | 答案 | 解析 |
|------|------|------|
| JSX 支持什么 | **D 以上都对** | HTML模板+表达式、条件+循环、点语法+展开 |
| 不是 React 内置分类 | **B FiberNode** | 内置分类是：有状态/内置类型/展示型 |
| 按定位分类的类型 | **C 容器组件** | 有状态/函数是按实现分，FiberNode是内部概念 |
| state 和 props 共同点错误 | **D 相同渲染结果相同** | 不同组合可能有相同输出 |
| 父组件标签间调用函数返回组件 | **C 以上两个都可以** | children 和 render props 都行 |
| key 属性错误说法 | **B 兄弟节点间不需要唯一** | key 在兄弟节点间必须唯一！ |
| 不是优化 state 的方法 | **B 减少不必要的根组件** | 这是优化渲染，不是优化 state |
| render/reconciliation 对应生命周期 | **A** | componentWillMount/ReceiveProps/ShouldUpdate/WillUpdate |

---

# 第九章 - 生命周期深度解析

## 生命周期全景图

```
┌────────────────────────────────────────────────────────────────────┐
│                        React 生命周期                               │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  ┌─────────────── 挂载阶段 (Mounting) ───────────────┐             │
│  │                                                   │             │
│  │  constructor → getDerivedStateFromProps →        │             │
│  │  render → componentDidMount                       │             │
│  │                                                   │             │
│  └───────────────────────────────────────────────────┘             │
│                           │                                        │
│                           ▼                                        │
│  ┌─────────────── 更新阶段 (Updating) ───────────────┐             │
│  │                                                   │             │
│  │  getDerivedStateFromProps → shouldComponentUpdate │             │
│  │  → render → getSnapshotBeforeUpdate →            │             │
│  │  componentDidUpdate                               │             │
│  │                                                   │             │
│  └───────────────────────────────────────────────────┘             │
│                           │                                        │
│                           ▼                                        │
│  ┌─────────────── 卸载阶段 (Unmounting) ─────────────┐             │
│  │                                                   │             │
│  │  componentWillUnmount                             │             │
│  │                                                   │             │
│  └───────────────────────────────────────────────────┘             │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

## 异步请求应该在哪个生命周期？

```jsx
class DataFetcher extends React.Component {
  state = { data: null, loading: true };

  // ✅ 正确：在 componentDidMount 中请求
  componentDidMount() {
    fetch('/api/data')
      .then(res => res.json())
      .then(data => this.setState({ data, loading: false }));
  }

  // ❌ 错误：不要在 constructor 或 componentWillMount 中请求
  // 原因：
  // 1. 这些方法在 render 之前，请求结果回来时组件可能还没挂载
  // 2. SSR 时会执行两次
  // 3. componentWillMount 已被废弃

  render() {
    if (this.state.loading) return <div>Loading...</div>;
    return <div>{this.state.data}</div>;
  }
}

// Hooks 写法
function DataFetcher() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
  }, []);  // 空依赖 = componentDidMount

  return data ? <div>{data}</div> : <div>Loading...</div>;
}
```

## useEffect vs useLayoutEffect

```
┌─────────────────────────────────────────────────────────────────┐
│              useEffect vs useLayoutEffect 执行时机               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  render → DOM 更新 → 浏览器绘制 → useEffect                     │
│                  │                                              │
│                  └→ useLayoutEffect（绘制前同步执行）            │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│  useEffect         │  useLayoutEffect                          │
├────────────────────┼────────────────────────────────────────────┤
│  异步执行           │  同步执行                                  │
│  不阻塞绘制         │  阻塞绘制                                  │
│  大多数场景         │  需要同步测量/修改 DOM                     │
│  ≈ componentDidMount│  ≈ componentDidMount + 同步               │
└────────────────────┴────────────────────────────────────────────┘
```

```jsx
// useEffect：适合大多数副作用
useEffect(() => {
  document.title = `Count: ${count}`;
}, [count]);

// useLayoutEffect：需要同步测量 DOM
function Tooltip({ children, targetRef }) {
  const [position, setPosition] = useState({ top: 0, left: 0 });
  
  useLayoutEffect(() => {
    // 在绘制前同步计算位置，避免闪烁
    const rect = targetRef.current.getBoundingClientRect();
    setPosition({ top: rect.bottom, left: rect.left });
  }, [targetRef]);
  
  return <div style={position}>{children}</div>;
}
```

## constructor 中 super 的意义

```jsx
class Child extends React.Component {
  constructor(props) {
    super(props);  // 必须调用！
    
    // 为什么？
    // 1. ES6 规定：子类必须在 constructor 中调用 super()
    // 2. 传入 props：让 this.props 在 constructor 中可用
    
    this.state = { count: 0 };
    console.log(this.props);  // 如果不传 props，这里是 undefined
  }
}

// 如果不需要在 constructor 中使用 this.props
// 可以省略 constructor，使用类字段语法
class Child extends React.Component {
  state = { count: 0 };  // 类字段，无需 constructor
  
  render() {
    return <div>{this.props.name}</div>;  // 这里 props 可用
  }
}
```

## Hooks 与生命周期对照

```jsx
// Class 组件生命周期 → Hooks 对应
class ClassComponent extends React.Component {
  constructor(props) {
    // → useState 的初始值 / useRef
  }
  
  componentDidMount() {
    // → useEffect(() => {...}, [])
  }
  
  componentDidUpdate(prevProps, prevState) {
    // → useEffect(() => {...}, [deps])
  }
  
  componentWillUnmount() {
    // → useEffect 的返回函数
  }
  
  shouldComponentUpdate(nextProps, nextState) {
    // → React.memo + useMemo
  }
}

// Hooks 完整对应
function HooksComponent({ id }) {
  // constructor: 初始化
  const [state, setState] = useState(initialValue);
  const ref = useRef(null);
  
  // componentDidMount + componentWillUnmount
  useEffect(() => {
    console.log('挂载');
    return () => console.log('卸载');
  }, []);
  
  // componentDidUpdate (依赖 id)
  useEffect(() => {
    console.log('id 变化了', id);
  }, [id]);
  
  // getDerivedStateFromProps
  const derivedValue = useMemo(() => {
    return computeFromProps(props);
  }, [props]);
  
  return <div>{state}</div>;
}
```

---

## 面试速记表

| 问题 | 答案要点 |
|------|----------|
| class 为什么变 className | JavaScript 保留字冲突 |
| PureComponent 区别 | 自动浅比较 props/state |
| setState 用法 | 对象、函数、回调三种 |
| 为什么 state 要新对象 | React 用引用比较判断更新 |
| Refs 适合场景 | 焦点、动画、第三方库、媒体控制 |
| 为什么单向数据流 | 可预测、易调试、单一职责 |
| Context 副作用 | 降低复用性、value 变化全更新 |
| 阻塞渲染 | 同步执行长任务阻塞 UI |
| Fiber 两阶段 | Render(可中断) + Commit(不可中断) |
| 异步请求在哪调 | componentDidMount / useEffect |
| useEffect vs useLayoutEffect | 异步/同步，绘制后/绘制前 |
| super(props) 意义 | ES6 规定 + 让 constructor 中可用 this.props |