## 第一性原理拆解：React 属性（Props）

### 核心问题：组件之间如何传递数据？

---

## 一、什么是 Props？

```
┌─────────────────────────────────────────────────────────┐
│  Props = 组件的入参                                      │
│                                                         │
│  • 父组件传递给子组件的数据                              │
│  • 只读，不能在子组件中修改                              │
│  • 可以是任意类型：数据、函数、组件、children            │
└─────────────────────────────────────────────────────────┘
```

```jsx
// 父组件传递 props
<UserCard name="John" age={25} onClick={handleClick} />

// 子组件接收 props
function UserCard({ name, age, onClick }) {
    return (
        <div onClick={onClick}>
            {name}: {age}岁
        </div>
    );
}
```

---

## 二、为什么 Props 是只读的？

```
┌─────────────────────────────────────────────────────────┐
│  React 核心原则：单向数据流                              │
│                                                         │
│  • 数据从父组件流向子组件                                │
│  • 子组件不能直接修改父组件的数据                        │
│  • 保证组件像纯函数一样：相同 props → 相同输出           │
│  • 便于调试和追踪数据变化                                │
└─────────────────────────────────────────────────────────┘
```

```jsx
// ❌ 错误：直接修改 props
function Child({ user }) {
    user.name = 'Jane';  // 禁止！
    return <div>{user.name}</div>;
}

// ✅ 正确：通过回调通知父组件
function Child({ user, onUserChange }) {
    const handleClick = () => {
        onUserChange({ ...user, name: 'Jane' });
    };
    return <div onClick={handleClick}>{user.name}</div>;
}
```

---

## 三、传递组件的方式

### 1. props.children

```jsx
// 父组件：标签之间的内容作为 children
function Card({ children, title }) {
    return (
        <div className="card">
            <h2>{title}</h2>
            <div className="content">{children}</div>
        </div>
    );
}

// 使用
<Card title="用户信息">
    <p>姓名：John</p>
    <p>年龄：25</p>
</Card>
```

### 2. Render Props

```jsx
// 通过 props 传递渲染函数
function Mouse({ render }) {
    const [position, setPosition] = useState({ x: 0, y: 0 });
    
    useEffect(() => {
        const handleMove = (e) => {
            setPosition({ x: e.clientX, y: e.clientY });
        };
        window.addEventListener('mousemove', handleMove);
        return () => window.removeEventListener('mousemove', handleMove);
    }, []);
    
    return render(position);
}

// 使用
<Mouse render={({ x, y }) => (
    <div>鼠标位置：{x}, {y}</div>
)} />

// 或者使用 children 作为函数
<Mouse>
    {({ x, y }) => <div>鼠标位置：{x}, {y}</div>}
</Mouse>
```

### 3. 组件作为 Props

```jsx
function Layout({ header, sidebar, content }) {
    return (
        <div className="layout">
            <header>{header}</header>
            <aside>{sidebar}</aside>
            <main>{content}</main>
        </div>
    );
}

// 使用
<Layout 
    header={<Header />}
    sidebar={<Sidebar />}
    content={<MainContent />}
/>
```

---

## 四、key 属性详解

### 作用：帮助 React 识别哪些元素改变了

```jsx
// ❌ 不使用 key 或使用 index 作为 key
{items.map((item, index) => (
    <li key={index}>{item.name}</li>  // 可能导致问题
))}

// ✅ 使用唯一且稳定的 id
{items.map(item => (
    <li key={item.id}>{item.name}</li>
))}
```

### 经典面试：为什么不推荐用 index 作为 key？

```jsx
// 场景：列表重新排序或在头部插入元素

// 原列表
[{ id: 1, name: 'A' }, { id: 2, name: 'B' }]
// key=0: A, key=1: B

// 在头部插入新元素后
[{ id: 3, name: 'C' }, { id: 1, name: 'A' }, { id: 2, name: 'B' }]
// key=0: C, key=1: A, key=2: B

// 问题：React 认为 key=0 的元素从 A 变成了 C
// 导致：错误的 DOM 更新、状态错乱

// 正确做法：使用 item.id 作为 key
// key=3: C（新增）, key=1: A（保持）, key=2: B（保持）
```

### key 的注意事项

```jsx
// 1. key 只在兄弟节点间唯一
<ul>
    {items.map(item => <li key={item.id}>{item.name}</li>)}
</ul>
<ol>
    {items.map(item => <li key={item.id}>{item.name}</li>)}  {/* 可以重复 */}
</ol>

// 2. key 不会传递给子组件
<Item key={item.id} id={item.id} />  // 需要单独传 id

// 3. 用 key 重置组件状态
<Counter key={userId} />  // userId 变化时，Counter 完全重新挂载
```

---

## 五、类型检查

### 1. PropTypes（运行时检查）

```jsx
import PropTypes from 'prop-types';

function User({ name, age, email, friends, onClick }) {
    return <div>{name}</div>;
}

User.propTypes = {
    // 基础类型
    name: PropTypes.string.isRequired,  // 必填字符串
    age: PropTypes.number,
    
    // 多种类型
    id: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.number
    ]),
    
    // 枚举
    status: PropTypes.oneOf(['active', 'inactive']),
    
    // 数组和对象
    friends: PropTypes.arrayOf(PropTypes.string),
    user: PropTypes.shape({
        name: PropTypes.string,
        age: PropTypes.number
    }),
    
    // 函数
    onClick: PropTypes.func,
    
    // React 元素
    children: PropTypes.element,
    
    // 任意类型但必填
    data: PropTypes.any.isRequired
};

// 默认值
User.defaultProps = {
    age: 18,
    status: 'active'
};
```

### 2. TypeScript（编译时检查，推荐）

```tsx
// 定义 Props 类型
interface UserProps {
    name: string;
    age?: number;  // 可选
    status: 'active' | 'inactive';
    friends: string[];
    user: {
        name: string;
        age: number;
    };
    onClick: (id: number) => void;
    children?: React.ReactNode;
}

// 使用
function User({ name, age = 18, status, onClick }: UserProps) {
    return <div onClick={() => onClick(1)}>{name}</div>;
}

// 或者使用 React.FC（不推荐，有一些问题）
const User: React.FC<UserProps> = ({ name, age = 18 }) => {
    return <div>{name}</div>;
};
```

### PropTypes vs TypeScript

| 特性 | PropTypes | TypeScript |
|------|-----------|------------|
| 检查时机 | 运行时 | 编译时 |
| 错误提示 | 控制台警告 | IDE 实时提示 |
| 性能影响 | 有（生产环境可移除） | 无 |
| 学习成本 | 低 | 中 |
| 推荐度 | 一般 | ⭐ 推荐 |

---

## 六、默认值设置

### 函数组件

```jsx
// 方法 1：参数默认值（推荐）
function Button({ text = 'Click', type = 'primary', size = 'medium' }) {
    return <button className={`btn-${type} btn-${size}`}>{text}</button>;
}

// 方法 2：defaultProps
Button.defaultProps = {
    text: 'Click',
    type: 'primary',
    size: 'medium'
};
```

### 类组件

```jsx
class Button extends React.Component {
    static defaultProps = {
        text: 'Click',
        type: 'primary'
    };
    
    render() {
        return <button>{this.props.text}</button>;
    }
}
```

### 注意：undefined vs null

```jsx
// defaultProps 只对 undefined 生效
<Button text={undefined} />  // 使用默认值 'Click'
<Button text={null} />       // 显示 null（空）

// 参数默认值也一样
function Button({ text = 'Click' }) {
    // text 为 undefined 时使用默认值
    // text 为 null 时值就是 null
}
```

---

## 七、HTML 属性差异

### 命名差异

```jsx
// HTML → JSX
// class → className
<div className="container" />

// for → htmlFor
<label htmlFor="email">Email:</label>

// tabindex → tabIndex（驼峰）
<input tabIndex={1} />

// onclick → onClick（驼峰）
<button onClick={handleClick}>Click</button>
```

### 特殊属性

```jsx
// style：对象而非字符串
<div style={{ backgroundColor: 'red', fontSize: '16px' }} />

// checked / value：受控组件
<input type="checkbox" checked={isChecked} onChange={handleChange} />
<input type="text" value={text} onChange={handleChange} />

// defaultChecked / defaultValue：非受控组件
<input type="checkbox" defaultChecked={true} />
<input type="text" defaultValue="初始值" />

// dangerouslySetInnerHTML：插入 HTML
<div dangerouslySetInnerHTML={{ __html: '<strong>Bold</strong>' }} />

// suppressContentEditableWarning：禁止警告
<div contentEditable suppressContentEditableWarning>可编辑</div>
```

### 自定义属性

```jsx
// React 16+ 支持自定义属性
<div data-testid="user-card" custom-attr="value" />
// 会渲染到 DOM 上
```

---

## 八、经典面试代码

### 1. Props 透传

```jsx
// 透传所有 props
function Button({ className, ...rest }) {
    return <button className={`btn ${className}`} {...rest} />;
}

// 使用
<Button className="primary" onClick={handleClick} disabled>
    Click
</Button>
```

### 2. 默认合并 Props

```jsx
function Input({ className = '', style = {}, ...rest }) {
    return (
        <input 
            className={`input ${className}`}
            style={{ padding: '8px', ...style }}
            {...rest}
        />
    );
}
```

### 3. 条件传递 Props

```jsx
function Button({ isLoading, ...props }) {
    return (
        <button 
            disabled={isLoading}
            {...props}
            // 条件属性
            {...(isLoading && { 'aria-busy': true })}
        >
            {isLoading ? 'Loading...' : props.children}
        </button>
    );
}
```

### 4. 克隆并注入 Props

```jsx
function Form({ children }) {
    const [formData, setFormData] = useState({});
    
    return (
        <form>
            {React.Children.map(children, child => {
                if (React.isValidElement(child)) {
                    return React.cloneElement(child, {
                        value: formData[child.props.name],
                        onChange: (e) => setFormData(prev => ({
                            ...prev,
                            [child.props.name]: e.target.value
                        }))
                    });
                }
                return child;
            })}
        </form>
    );
}
```

### 5. 避免匿名函数导致重渲染

```jsx
// ❌ 每次渲染创建新函数
<List 
    render={(item) => <Item data={item} />}  // 匿名函数
/>

// ✅ 使用 useCallback 或提取为组件
const renderItem = useCallback((item) => <Item data={item} />, []);
<List render={renderItem} />

// 或者
const ItemRenderer = ({ item }) => <Item data={item} />;
<List render={ItemRenderer} />
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    React Props 核心要点                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Props 本质                                                     │
│  ├── 组件的入参，父传子                                         │
│  ├── 只读，保证单向数据流                                       │
│  └── 可传任意类型：数据、函数、组件、children                   │
│                                                                 │
│  传递组件方式                                                   │
│  ├── children：标签之间的内容                                   │
│  ├── Render Props：传递渲染函数                                 │
│  └── 组件作为 Props：灵活组合                                   │
│                                                                 │
│  key 属性                                                       │
│  ├── 帮助 React 识别元素变化                                    │
│  ├── 必须唯一且稳定                                             │
│  ├── 避免使用 index（除非列表静态）                             │
│  └── 不会传递给子组件                                           │
│                                                                 │
│  类型检查                                                       │
│  ├── PropTypes：运行时，控制台警告                              │
│  └── TypeScript：编译时，推荐                                   │
│                                                                 │
│  默认值                                                         │
│  ├── 参数默认值（推荐）                                         │
│  ├── defaultProps                                               │
│  └── 只对 undefined 生效，null 不生效                           │
│                                                                 │
│  HTML 差异                                                      │
│  ├── class → className                                          │
│  ├── for → htmlFor                                              │
│  └── style 是对象，事件是驼峰                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心记忆：Props 是只读的入参，key 要唯一稳定，TypeScript 做类型检查，默认值只管 undefined。**