## 第一性原理拆解：React 组件

### 核心问题：如何将 UI 拆分为独立、可复用的代码片段？

---

## 一、什么是 React 组件？

```
┌─────────────────────────────────────────────────────────┐
│  组件 = 接受 Props，返回 React 元素的函数（或类）        │
│                                                         │
│  本质：UI 的封装单元                                     │
│  类比：JavaScript 函数，输入 props，输出 UI              │
└─────────────────────────────────────────────────────────┘
```

```jsx
// 最简单的组件
function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
}

// 使用
<Welcome name="React" />
```

---

## 二、组件分类

### 按定义方式

| 类型 | 类组件 | 函数组件 |
|------|--------|----------|
| 语法 | ES6 class | 普通函数 |
| state | this.state + setState | useState Hook |
| 生命周期 | 生命周期方法 | useEffect Hook |
| this | 有，需要绑定 | 无 |
| 性能 | 需要实例化 | 更轻量 |

```jsx
// 类组件
class Welcome extends React.Component {
    state = { count: 0 };
    
    handleClick = () => {
        this.setState({ count: this.state.count + 1 });
    };
    
    render() {
        return (
            <div onClick={this.handleClick}>
                Count: {this.state.count}
            </div>
        );
    }
}

// 函数组件（推荐）
function Welcome() {
    const [count, setCount] = useState(0);
    
    return (
        <div onClick={() => setCount(count + 1)}>
            Count: {count}
        </div>
    );
}
```

### 按职责分

| 类型 | 展示组件 | 容器组件 |
|------|----------|----------|
| 关注点 | UI 长什么样 | 数据和逻辑 |
| 数据来源 | props | state/store |
| 状态 | 通常无状态 | 有状态 |
| 副作用 | 无 | 有（请求、订阅等） |

```jsx
// 展示组件：只关心 UI
function UserCard({ name, avatar, onClick }) {
    return (
        <div className="card" onClick={onClick}>
            <img src={avatar} alt={name} />
            <h3>{name}</h3>
        </div>
    );
}

// 容器组件：关心数据和逻辑
function UserCardContainer({ userId }) {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        fetchUser(userId).then(data => {
            setUser(data);
            setLoading(false);
        });
    }, [userId]);
    
    if (loading) return <Spinner />;
    
    return (
        <UserCard 
            name={user.name} 
            avatar={user.avatar}
            onClick={() => console.log('clicked')}
        />
    );
}
```

---

## 三、受控组件 vs 非受控组件

### 受控组件：React 控制表单数据

```jsx
function ControlledInput() {
    const [value, setValue] = useState('');
    
    const handleChange = (e) => {
        setValue(e.target.value);
    };
    
    const handleSubmit = (e) => {
        e.preventDefault();
        console.log('提交:', value);
    };
    
    return (
        <form onSubmit={handleSubmit}>
            <input 
                type="text" 
                value={value}           // React 控制值
                onChange={handleChange} // 每次变化都更新 state
            />
            <button type="submit">提交</button>
        </form>
    );
}
```

### 非受控组件：DOM 控制表单数据

```jsx
function UncontrolledInput() {
    const inputRef = useRef(null);
    
    const handleSubmit = (e) => {
        e.preventDefault();
        console.log('提交:', inputRef.current.value);  // 从 DOM 获取
    };
    
    return (
        <form onSubmit={handleSubmit}>
            <input 
                type="text" 
                defaultValue="默认值"  // 只设置初始值
                ref={inputRef}          // 通过 ref 获取 DOM
            />
            <button type="submit">提交</button>
        </form>
    );
}
```

### 对比

| 特性 | 受控组件 | 非受控组件 |
|------|----------|------------|
| 数据存储 | React state | DOM |
| 获取值 | state | ref.current.value |
| 实时验证 | ✅ 容易 | ❌ 困难 |
| 代码量 | 多（每个输入需要 handler） | 少 |
| 推荐场景 | 表单验证、动态交互 | 简单表单、文件上传 |

```jsx
// 文件上传只能用非受控（value 只读）
function FileInput() {
    const fileRef = useRef(null);
    
    const handleSubmit = () => {
        const file = fileRef.current.files[0];
        console.log(file);
    };
    
    return <input type="file" ref={fileRef} />;
}
```

---

## 四、高阶组件（HOC）

### 本质：组件 → 组件 的函数

```
┌─────────────────────────────────────────────────────────┐
│  HOC = Higher-Order Component                           │
│  接收一个组件，返回一个新的增强组件                      │
│  类似于高阶函数：函数 → 函数                            │
└─────────────────────────────────────────────────────────┘
```

### 经典代码：withLoading

```jsx
// 高阶组件：添加 loading 功能
function withLoading(WrappedComponent) {
    return function WithLoading({ isLoading, ...props }) {
        if (isLoading) {
            return <div>Loading...</div>;
        }
        return <WrappedComponent {...props} />;
    };
}

// 使用
const UserListWithLoading = withLoading(UserList);

<UserListWithLoading isLoading={loading} users={users} />
```

### 经典代码：withAuth

```jsx
// 高阶组件：权限控制
function withAuth(WrappedComponent) {
    return function WithAuth(props) {
        const { isAuthenticated } = useAuth();
        
        if (!isAuthenticated) {
            return <Navigate to="/login" />;
        }
        
        return <WrappedComponent {...props} />;
    };
}

// 使用
const ProtectedDashboard = withAuth(Dashboard);
```

### 经典代码：withLogger

```jsx
// 高阶组件：日志记录
function withLogger(WrappedComponent) {
    return class WithLogger extends React.Component {
        componentDidMount() {
            console.log(`${WrappedComponent.name} mounted`);
        }
        
        componentDidUpdate(prevProps) {
            console.log(`${WrappedComponent.name} updated`, {
                prevProps,
                currentProps: this.props
            });
        }
        
        render() {
            return <WrappedComponent {...this.props} />;
        }
    };
}
```

### HOC 最佳实践

```jsx
// 1. 不要改变原组件，使用组合
// ❌ 错误
function withSomething(WrappedComponent) {
    WrappedComponent.prototype.doSomething = () => {};  // 修改原型
    return WrappedComponent;
}

// ✅ 正确
function withSomething(WrappedComponent) {
    return function WithSomething(props) {
        return <WrappedComponent {...props} doSomething={() => {}} />;
    };
}

// 2. 透传无关 props
function withSomething(WrappedComponent) {
    return function WithSomething({ extraProp, ...restProps }) {
        // extraProp 是 HOC 使用的
        // restProps 透传给原组件
        return <WrappedComponent {...restProps} />;
    };
}

// 3. 设置 displayName 便于调试
function withSomething(WrappedComponent) {
    function WithSomething(props) {
        return <WrappedComponent {...props} />;
    }
    
    WithSomething.displayName = `WithSomething(${
        WrappedComponent.displayName || WrappedComponent.name
    })`;
    
    return WithSomething;
}
```

---

## 五、Pure Component

### 本质：自动实现 shouldComponentUpdate 的浅比较

```jsx
// React.Component：每次父组件更新都会重新渲染
class NormalComponent extends React.Component {
    render() {
        console.log('NormalComponent render');
        return <div>{this.props.name}</div>;
    }
}

// React.PureComponent：props/state 浅比较，相同则不渲染
class PureComponentExample extends React.PureComponent {
    render() {
        console.log('PureComponent render');
        return <div>{this.props.name}</div>;
    }
}

// 函数组件等价：React.memo
const MemoComponent = React.memo(function MyComponent({ name }) {
    console.log('MemoComponent render');
    return <div>{name}</div>;
});
```

### 浅比较的坑

```jsx
// ❌ 问题：对象引用变化，即使内容相同也会重新渲染
function Parent() {
    const [count, setCount] = useState(0);
    
    // 每次渲染都创建新对象
    const user = { name: 'John' };
    const handleClick = () => console.log('click');
    
    return (
        <>
            <button onClick={() => setCount(count + 1)}>+</button>
            <MemoChild user={user} onClick={handleClick} />
        </>
    );
}

// ✅ 解决：useMemo + useCallback
function Parent() {
    const [count, setCount] = useState(0);
    
    const user = useMemo(() => ({ name: 'John' }), []);
    const handleClick = useCallback(() => console.log('click'), []);
    
    return (
        <>
            <button onClick={() => setCount(count + 1)}>+</button>
            <MemoChild user={user} onClick={handleClick} />
        </>
    );
}
```

---

## 六、组件设计原则

### 设计步骤

```
1. 分析 UI 和数据结构
   ↓
2. 划分组件层级（单一职责）
   ↓
3. 构建静态版本（props 传递，无 state）
   ↓
4. 确定最小 state
   ↓
5. 确定 state 位置（共同父组件）
   ↓
6. 添加反向数据流（回调函数）
```

### 判断是否需要 state

```
数据是否应该是 state？
├── 从 props 传入？→ ❌ 不是 state
├── 始终不变？→ ❌ 不是 state
├── 可以从其他 state/props 计算得出？→ ❌ 不是 state
└── 以上都不是？→ ✅ 是 state
```

### 经典代码：可搜索的产品列表

```jsx
// 1. 划分组件
// FilterableProductTable
//   ├── SearchBar
//   └── ProductTable
//        ├── ProductCategoryRow
//        └── ProductRow

// 2. 静态版本 + 确定 state（搜索词、是否只显示有库存）
function FilterableProductTable({ products }) {
    const [filterText, setFilterText] = useState('');
    const [inStockOnly, setInStockOnly] = useState(false);
    
    return (
        <div>
            <SearchBar 
                filterText={filterText}
                inStockOnly={inStockOnly}
                onFilterTextChange={setFilterText}      // 反向数据流
                onInStockOnlyChange={setInStockOnly}
            />
            <ProductTable 
                products={products}
                filterText={filterText}
                inStockOnly={inStockOnly}
            />
        </div>
    );
}

function SearchBar({ filterText, inStockOnly, onFilterTextChange, onInStockOnlyChange }) {
    return (
        <form>
            <input 
                type="text"
                value={filterText}
                placeholder="Search..."
                onChange={(e) => onFilterTextChange(e.target.value)}
            />
            <label>
                <input 
                    type="checkbox"
                    checked={inStockOnly}
                    onChange={(e) => onInStockOnlyChange(e.target.checked)}
                />
                Only show products in stock
            </label>
        </form>
    );
}

function ProductTable({ products, filterText, inStockOnly }) {
    const filteredProducts = products.filter(product => {
        if (inStockOnly && !product.stocked) return false;
        if (!product.name.toLowerCase().includes(filterText.toLowerCase())) return false;
        return true;
    });
    
    // 渲染逻辑...
}
```

---

## 七、组件复用模式对比

| 模式 | HOC | Render Props | Hooks |
|------|-----|--------------|-------|
| 形式 | 函数包装组件 | props 传递渲染函数 | 函数调用 |
| 复用 | 逻辑复用 | 逻辑复用 | 逻辑复用 |
| 嵌套 | 多层嵌套 | 回调嵌套 | 扁平 |
| 推荐度 | 一般 | 一般 | ⭐ 推荐 |

```jsx
// HOC
const EnhancedComponent = withMouse(MyComponent);

// Render Props
<Mouse render={mouse => <Cat position={mouse} />} />

// Hooks（推荐）
function MyComponent() {
    const mouse = useMouse();
    return <Cat position={mouse} />;
}
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    React 组件核心要点                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  组件本质                                                       │
│  └── 接收 Props，返回 React 元素的函数/类                       │
│                                                                 │
│  分类                                                           │
│  ├── 类组件 vs 函数组件（推荐函数组件 + Hooks）                 │
│  ├── 展示组件 vs 容器组件（关注点分离）                         │
│  └── 受控 vs 非受控（表单数据谁管理）                           │
│                                                                 │
│  复用模式                                                       │
│  ├── HOC：高阶组件，组件 → 组件                                 │
│  ├── Render Props：通过 props 传递渲染函数                      │
│  └── Hooks：最推荐，扁平化复用逻辑                              │
│                                                                 │
│  性能优化                                                       │
│  ├── PureComponent：类组件浅比较                                │
│  ├── React.memo：函数组件浅比较                                 │
│  └── useMemo/useCallback：避免引用变化                          │
│                                                                 │
│  设计原则                                                       │
│  ├── 单一职责                                                   │
│  ├── 最小 state                                                 │
│  └── 状态提升 + 反向数据流                                      │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心记忆：组件是 UI 封装单元，函数组件 + Hooks 是主流，受控组件 React 管数据，HOC/Hooks 复用逻辑。**