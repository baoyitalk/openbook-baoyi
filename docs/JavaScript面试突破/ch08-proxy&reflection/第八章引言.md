## 第一性原理拆解：Proxy & Reflection

### 核心问题：如何拦截和自定义对象的基本操作？

---

## 一、为什么需要 Proxy？

```
┌─────────────────────────────────────────────────────────┐
│  问题：Object.defineProperty 的局限性                   │
├─────────────────────────────────────────────────────────┤
│  • 只能监听已存在的属性，新增/删除属性无法监听          │
│  • 需要遍历对象的每个属性单独设置                       │
│  • 数组的 push/pop/splice 等方法无法触发 setter         │
│  • 深层嵌套需要递归处理                                 │
└─────────────────────────────────────────────────────────┘

Vue2 使用 Object.defineProperty → 有上述限制
Vue3 使用 Proxy → 解决了这些问题
```

---

## 二、Object.defineProperty

### 基本用法

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
    value: 'John',
    writable: true,      // 是否可修改
    enumerable: true,    // 是否可枚举（for...in）
    configurable: true   // 是否可删除/重新配置
});
```

### 用于数据劫持（getter/setter）

```javascript
const obj = { _name: 'John' };

Object.defineProperty(obj, 'name', {
    get() {
        console.log('读取 name');
        return this._name;
    },
    set(value) {
        console.log('设置 name:', value);
        this._name = value;
    }
});

obj.name;           // 打印 "读取 name"
obj.name = 'Jane';  // 打印 "设置 name: Jane"
```

### 局限性演示

```javascript
const obj = { a: 1 };

// 必须遍历每个属性
Object.keys(obj).forEach(key => {
    let value = obj[key];
    Object.defineProperty(obj, key, {
        get() { return value; },
        set(newVal) { value = newVal; }
    });
});

// ❌ 新增属性无法监听
obj.b = 2;  // 没有触发 setter

// ❌ 数组方法无法监听
const arr = [1, 2, 3];
arr.push(4);  // 无法触发
```

---

## 三、Proxy

### 本质：创建一个代理对象，拦截对目标对象的所有操作

```javascript
const proxy = new Proxy(target, handler);
// target: 被代理的对象
// handler: 定义拦截行为的对象
```

### 13 种可拦截的操作

| 陷阱（trap） | 触发条件 |
|-------------|----------|
| `get` | 读取属性 |
| `set` | 设置属性 |
| `has` | `in` 操作符 |
| `deleteProperty` | `delete` 操作符 |
| `ownKeys` | `Object.keys()` / `for...in` |
| `getOwnPropertyDescriptor` | `Object.getOwnPropertyDescriptor()` |
| `defineProperty` | `Object.defineProperty()` |
| `getPrototypeOf` | `Object.getPrototypeOf()` |
| `setPrototypeOf` | `Object.setPrototypeOf()` |
| `isExtensible` | `Object.isExtensible()` |
| `preventExtensions` | `Object.preventExtensions()` |
| `apply` | 函数调用 |
| `construct` | `new` 操作符 |

### 基本使用

```javascript
const target = { name: 'John', age: 20 };

const proxy = new Proxy(target, {
    get(target, key, receiver) {
        console.log(`读取 ${key}`);
        return Reflect.get(target, key, receiver);
    },
    set(target, key, value, receiver) {
        console.log(`设置 ${key} = ${value}`);
        return Reflect.set(target, key, value, receiver);
    },
    deleteProperty(target, key) {
        console.log(`删除 ${key}`);
        return Reflect.deleteProperty(target, key);
    },
    has(target, key) {
        console.log(`检查 ${key} 是否存在`);
        return Reflect.has(target, key);
    }
});

proxy.name;           // 读取 name
proxy.age = 21;       // 设置 age = 21
proxy.gender = 'M';   // 设置 gender = M（新增属性也能监听！）
delete proxy.age;     // 删除 age
'name' in proxy;      // 检查 name 是否存在
```

---

## 四、Reflect

### 本质：提供操作对象的标准方法，与 Proxy 的 handler 方法一一对应

### 为什么需要 Reflect？

```javascript
// 1. 统一返回值（返回布尔值，而不是抛出错误）
// 旧方式
try {
    Object.defineProperty(obj, 'name', { value: 1 });
    // 成功
} catch (e) {
    // 失败
}

// 新方式
if (Reflect.defineProperty(obj, 'name', { value: 1 })) {
    // 成功
} else {
    // 失败
}

// 2. 函数式操作（代替命令式）
// 旧方式
'name' in obj;
delete obj.name;

// 新方式
Reflect.has(obj, 'name');
Reflect.deleteProperty(obj, 'name');

// 3. 保持正确的 this 绑定
const proxy = new Proxy(target, {
    get(target, key, receiver) {
        // receiver 是 proxy 本身，保证 this 指向正确
        return Reflect.get(target, key, receiver);
    }
});
```

### Reflect 方法对照表

| Reflect 方法 | 等价操作 |
|-------------|----------|
| `Reflect.get(obj, 'key')` | `obj.key` |
| `Reflect.set(obj, 'key', value)` | `obj.key = value` |
| `Reflect.has(obj, 'key')` | `'key' in obj` |
| `Reflect.deleteProperty(obj, 'key')` | `delete obj.key` |
| `Reflect.ownKeys(obj)` | `Object.keys(obj)` + Symbol keys |
| `Reflect.construct(Fn, args)` | `new Fn(...args)` |
| `Reflect.apply(fn, thisArg, args)` | `fn.apply(thisArg, args)` |

---

## 五、Object.defineProperty vs Proxy（核心面试题）

| 特性 | Object.defineProperty | Proxy |
|------|----------------------|-------|
| 监听目标 | 单个属性 | 整个对象 |
| 新增属性 | ❌ 无法监听 | ✅ 可以监听 |
| 删除属性 | ❌ 无法监听 | ✅ 可以监听 |
| 数组方法 | ❌ 需要重写 | ✅ 原生支持 |
| 深层嵌套 | 需要递归 | 可惰性代理 |
| 性能 | 初始化开销大 | 惰性代理更优 |
| 兼容性 | IE9+ | IE 不支持 |

---

## 六、经典面试代码

### 1. 手写响应式（Vue3 简化版）

```javascript
function reactive(target) {
    return new Proxy(target, {
        get(target, key, receiver) {
            console.log(`收集依赖: ${key}`);
            const result = Reflect.get(target, key, receiver);
            // 深层代理
            if (typeof result === 'object' && result !== null) {
                return reactive(result);
            }
            return result;
        },
        set(target, key, value, receiver) {
            console.log(`触发更新: ${key} = ${value}`);
            return Reflect.set(target, key, value, receiver);
        },
        deleteProperty(target, key) {
            console.log(`删除属性: ${key}`);
            return Reflect.deleteProperty(target, key);
        }
    });
}

// 测试
const state = reactive({
    name: 'John',
    info: { age: 20 }
});

state.name;           // 收集依赖: name
state.name = 'Jane';  // 触发更新: name = Jane
state.gender = 'M';   // 触发更新: gender = M（新增也能监听）
state.info.age = 21;  // 收集依赖: info → 触发更新: age = 21
```

### 2. 数据验证

```javascript
const validator = {
    set(target, key, value) {
        if (key === 'age') {
            if (typeof value !== 'number') {
                throw new TypeError('age 必须是数字');
            }
            if (value < 0 || value > 150) {
                throw new RangeError('age 必须在 0-150 之间');
            }
        }
        return Reflect.set(target, key, value);
    }
};

const person = new Proxy({}, validator);
person.age = 25;    // ✅
person.age = -1;    // ❌ RangeError
person.age = 'old'; // ❌ TypeError
```

### 3. 私有属性

```javascript
const handler = {
    get(target, key) {
        if (key.startsWith('_')) {
            throw new Error(`属性 ${key} 是私有的`);
        }
        return Reflect.get(target, key);
    },
    set(target, key, value) {
        if (key.startsWith('_')) {
            throw new Error(`属性 ${key} 是私有的`);
        }
        return Reflect.set(target, key, value);
    },
    has(target, key) {
        if (key.startsWith('_')) {
            return false;
        }
        return Reflect.has(target, key);
    },
    ownKeys(target) {
        return Reflect.ownKeys(target).filter(k => !k.startsWith('_'));
    }
};

const obj = new Proxy({ name: 'John', _secret: '123' }, handler);
obj.name;        // 'John'
obj._secret;     // ❌ Error
'_secret' in obj // false
Object.keys(obj) // ['name']
```

### 4. 函数调用拦截

```javascript
function sum(a, b) {
    return a + b;
}

const proxy = new Proxy(sum, {
    apply(target, thisArg, args) {
        console.log(`调用函数，参数: ${args}`);
        const start = performance.now();
        const result = Reflect.apply(target, thisArg, args);
        console.log(`执行耗时: ${performance.now() - start}ms`);
        return result;
    }
});

proxy(1, 2);  // 调用函数，参数: 1,2 → 执行耗时: 0.01ms → 3
```

### 5. 实现负数索引（Python 风格）

```javascript
function createArray(...items) {
    return new Proxy(items, {
        get(target, key, receiver) {
            const index = Number(key);
            if (index < 0) {
                key = String(target.length + index);
            }
            return Reflect.get(target, key, receiver);
        }
    });
}

const arr = createArray(1, 2, 3, 4, 5);
arr[-1];  // 5
arr[-2];  // 4
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    Proxy & Reflect 核心                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Object.defineProperty                                          │
│  ├── 监听单个属性的 get/set                                     │
│  ├── 无法监听新增/删除属性                                       │
│  ├── 数组方法需要重写                                           │
│  └── Vue2 的响应式方案                                          │
│                                                                 │
│  Proxy                                                          │
│  ├── 拦截整个对象的 13 种操作                                   │
│  ├── 可监听新增/删除/数组等所有操作                              │
│  ├── 惰性代理，性能更好                                         │
│  └── Vue3 的响应式方案                                          │
│                                                                 │
│  Reflect                                                        │
│  ├── 与 Proxy handler 一一对应                                  │
│  ├── 统一返回值（布尔值而非抛错）                                │
│  ├── 函数式操作代替命令式                                       │
│  └── 保持正确的 receiver（this 绑定）                           │
│                                                                 │
│  最佳实践                                                       │
│  └── Proxy + Reflect 配合使用，Reflect 作为默认行为             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心记忆：defineProperty 监听属性，Proxy 监听对象，Reflect 是 Proxy 的好搭档。**