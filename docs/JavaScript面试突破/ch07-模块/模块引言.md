## 第一性原理拆解：JavaScript 模块化

### 核心问题：如何将代码拆分成独立、可复用、无冲突的单元？

---

## 一、为什么需要模块化？

```
早期 JS 的问题：
┌─────────────────────────────────────────┐
│  1. 全局变量污染（命名冲突）            │
│  2. 依赖关系混乱（加载顺序难管理）      │
│  3. 代码复用困难                        │
└─────────────────────────────────────────┘
```

---

## 二、模块化的演进历程

```
全局函数 → 命名空间 → IIFE → CommonJS → AMD → UMD → ES Modules
   ↓          ↓        ↓         ↓        ↓      ↓        ↓
 最原始    减少冲突   闭包隔离   Node.js  浏览器  通用     标准
```

---

## 三、早期模块化方案

### 1. 全局函数

```javascript
// 问题：全部暴露在全局，容易冲突
var name = "module1";
function getName() {
    return name;
}
```

### 2. 命名空间

```javascript
// 改进：减少全局变量数量
var myModule = {
    name: "module1",
    getName: function() {
        return this.name;
    }
};

myModule.getName();  // "module1"

// 问题：内部属性可被外部修改
myModule.name = "hacked";  // 不安全
```

### 3. IIFE（立即执行函数）

```javascript
// 改进：通过闭包创建私有作用域
var myModule = (function() {
    var name = "module1";  // 私有变量
    
    return {
        getName: function() {
            return name;
        }
    };
})();

myModule.getName();  // "module1"
myModule.name;       // undefined（无法访问）
```

### 4. IIFE 增强版（依赖注入）

```javascript
var myModule = (function($, _) {
    // 内部使用 jQuery 和 lodash
    var $div = $('<div>');
    
    return {
        // ...
    };
})(jQuery, lodash);
```

---

## 四、CommonJS（Node.js 标准）

### 特点

```
┌────────────────────────────────────────────────────┐
│  • 同步加载（适合服务端，文件在本地）              │
│  • 运行时加载（代码执行时才确定依赖）              │
│  • 值的拷贝（导出的是值的副本）                    │
│  • 模块可多次加载，但只在第一次执行，结果会缓存    │
└────────────────────────────────────────────────────┘
```

### 语法

```javascript
// 导出 —— module.exports
// math.js
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;

module.exports = { add, subtract };
// 或
exports.add = add;
exports.subtract = subtract;

// 导入 —— require
// main.js
const math = require('./math');
const { add } = require('./math');

console.log(math.add(1, 2));  // 3
console.log(add(1, 2));        // 3
```

### 经典面试题：exports vs module.exports

```javascript
// exports 是 module.exports 的引用
console.log(exports === module.exports);  // true

// 正确用法
exports.name = 'module';  // ✅ 添加属性

// 错误用法
exports = { name: 'module' };  // ❌ 断开了引用，无效

// 推荐用法
module.exports = { name: 'module' };  // ✅ 直接赋值
```

---

## 五、AMD（Asynchronous Module Definition）

### 特点

```
┌────────────────────────────────────────────────────┐
│  • 异步加载（适合浏览器，文件需网络请求）          │
│  • 依赖前置（在定义模块时声明所有依赖）            │
│  • 代表实现：RequireJS                             │
└────────────────────────────────────────────────────┘
```

### 语法

```javascript
// 定义模块
define('myModule', ['jquery', 'lodash'], function($, _) {
    // 模块代码
    return {
        // ...
    };
});

// 使用模块
require(['myModule'], function(myModule) {
    // 使用 myModule
});
```

---

## 六、CMD（Common Module Definition）

### 特点

```
┌────────────────────────────────────────────────────┐
│  • 异步加载                                        │
│  • 依赖就近（用到时再 require）                    │
│  • 代表实现：SeaJS（阿里）                         │
└────────────────────────────────────────────────────┘
```

### 语法

```javascript
define(function(require, exports, module) {
    // 按需加载
    var $ = require('jquery');
    
    // 用到时再加载
    if (condition) {
        var lodash = require('lodash');
    }
    
    exports.name = 'module';
});
```

---

## 七、UMD（Universal Module Definition）

### 特点：兼容 CommonJS、AMD 和全局变量

```javascript
(function(root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // 浏览器全局变量
        root.myModule = factory(root.jQuery);
    }
})(this, function($) {
    // 模块代码
    return {
        // ...
    };
});
```

---

## 八、ES Modules（ES6 标准）

### 特点

```
┌────────────────────────────────────────────────────┐
│  • 静态分析（编译时确定依赖，支持 Tree Shaking）   │
│  • 值的引用（导出的是值的实时绑定）                │
│  • 自动严格模式                                    │
│  • 浏览器和 Node.js 都支持                         │
└────────────────────────────────────────────────────┘
```

### 语法

```javascript
// 导出 —— export
// 命名导出
export const name = 'module';
export function add(a, b) { return a + b; }

// 默认导出
export default function() { /* ... */ }

// 导入 —— import
import defaultExport from './module';          // 默认导入
import { name, add } from './module';          // 命名导入
import { name as alias } from './module';      // 别名导入
import * as module from './module';            // 整体导入
import './module';                              // 仅执行，不导入
```

### 动态导入

```javascript
// import() 返回 Promise
button.onclick = async () => {
    const module = await import('./heavy-module.js');
    module.doSomething();
};
```

---

## 九、CommonJS vs ES Modules（核心面试题）

| 特性 | CommonJS | ES Modules |
|------|----------|------------|
| 加载时机 | 运行时 | 编译时 |
| 加载方式 | 同步 | 异步 |
| 导出值 | 值的拷贝 | 值的引用 |
| this 指向 | 当前模块 | undefined |
| 循环依赖 | 返回已执行部分 | 通过引用解决 |
| Tree Shaking | ❌ 不支持 | ✅ 支持 |

### 经典面试代码：值的拷贝 vs 值的引用

```javascript
// CommonJS —— 值的拷贝
// counter.js
let count = 0;
function increment() { count++; }
module.exports = { count, increment };

// main.js
const counter = require('./counter');
console.log(counter.count);  // 0
counter.increment();
console.log(counter.count);  // 0 ← 还是0！因为是拷贝


// ES Modules —— 值的引用
// counter.mjs
export let count = 0;
export function increment() { count++; }

// main.mjs
import { count, increment } from './counter.mjs';
console.log(count);  // 0
increment();
console.log(count);  // 1 ← 变成1！因为是引用
```

### 经典面试题：循环依赖

```javascript
// CommonJS 循环依赖
// a.js
exports.done = false;
const b = require('./b');  // 此时 b.done = true
console.log('在 a 中，b.done =', b.done);
exports.done = true;

// b.js
exports.done = false;
const a = require('./a');  // 此时 a.done = false（只执行了一部分）
console.log('在 b 中，a.done =', a.done);
exports.done = true;

// main.js
const a = require('./a');
// 输出：
// 在 b 中，a.done = false
// 在 a 中，b.done = true
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    JavaScript 模块化演进                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  早期方案                                                       │
│  ├── 全局函数 → 命名冲突                                        │
│  ├── 命名空间 → 可被修改                                        │
│  └── IIFE → 闭包隔离，但依赖管理麻烦                            │
│                                                                 │
│  社区方案                                                       │
│  ├── CommonJS → Node.js 标准，同步加载，值拷贝                  │
│  ├── AMD → 浏览器异步，依赖前置（RequireJS）                    │
│  ├── CMD → 浏览器异步，依赖就近（SeaJS）                        │
│  └── UMD → 兼容 CommonJS + AMD + 全局变量                       │
│                                                                 │
│  标准方案                                                       │
│  └── ES Modules → 静态分析，值引用，Tree Shaking                │
│                                                                 │
│  核心区别                                                       │
│  ├── CommonJS：运行时加载 + 值拷贝                              │
│  └── ES Modules：编译时加载 + 值引用                            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心记忆：CommonJS 是运行时拷贝，ESM 是编译时引用，现代开发用 ESM。**