

基于图片内容，我将用第一性原理拆解 JavaScript 核心概念：

## 一、第一性原理拆解

### 1. 对象本质：属性的容器
**最底层真理**：对象就是键值对的集合

```javascript
// 对象创建的本质
const obj = {}; // 字面量
const obj2 = new Object(); // 构造函数
const obj3 = Object.create(null); // 原型链

// 属性访问的两种方式
obj.name = 'test';  // 点语法
obj['name'] = 'test'; // 括号语法（更底层）
```

### 2. 原型链：对象间的委托关系
**最底层真理**：JavaScript 没有类，只有对象间的链接

```javascript
// 原型链的本质
function Person(name) {
  this.name = name;
}
Person.prototype.sayHi = function() {
  console.log(this.name);
};

const p = new Person('Alice');

// 查找链：p -> Person.prototype -> Object.prototype -> null
console.log(p.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
```

**逻辑图：**
```
实例对象 p
    ↓ __proto__
Person.prototype
    ↓ __proto__
Object.prototype
    ↓ __proto__
   null
```

### 3. 闭包：函数+词法作用域
**最底层真理**：函数记住了它被创建时的环境

```javascript
// 闭包的本质
function outer() {
  let count = 0; // 外部变量
  return function inner() {
    count++; // 内部函数访问外部变量
    return count;
  };
}

const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
// count 变量被"关闭"在闭包中，不会被垃圾回收
```

**经典面试题：循环中的闭包**
```javascript
// 错误示例
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 输出：3 3 3（因为 var 是函数作用域）

// 解决方案1：IIFE
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(() => console.log(j), 100);
  })(i);
}

// 解决方案2：let（块级作用域）
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 输出：0 1 2
```

### 4. 异步：单线程的时间分片
**最底层真理**：JavaScript 是单线程，通过事件循环处理异步

```javascript
// 事件循环机制
console.log('1');

setTimeout(() => {
  console.log('2'); // 宏任务
}, 0);

Promise.resolve().then(() => {
  console.log('3'); // 微任务
});

console.log('4');

// 输出顺序：1 4 3 2
```

**逻辑图：**
```
调用栈（Call Stack）
    ↓ 同步代码执行完
微任务队列（Microtask Queue）
    ↓ 微任务执行完
宏任务队列（Macrotask Queue）
    ↓ 取一个宏任务
回到调用栈
```

### 5. Promise：状态机 + 链式调用
**最底层真理**：Promise 是一个有三种状态的对象

```javascript
// Promise 的本质实现
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.callbacks = [];
    
    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.callbacks.forEach(cb => cb.onFulfilled(value));
      }
    };
    
    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.value = reason;
        this.callbacks.forEach(cb => cb.onRejected(reason));
      }
    };
    
    executor(resolve, reject);
  }
  
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        const result = onFulfilled(this.value);
        resolve(result);
      } else if (this.state === 'rejected') {
        const result = onRejected(this.value);
        reject(result);
      } else {
        this.callbacks.push({ onFulfilled, onRejected });
      }
    });
  }
}
```

## 二、经典面试代码合集

### 1. 实现 call/apply/bind
```javascript
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};

Function.prototype.myBind = function(context, ...args) {
  const fn = this;
  return function(...newArgs) {
    return fn.apply(context, [...args, ...newArgs]);
  };
};
```

### 2. 实现深拷贝
```javascript
function deepClone(obj, map = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (map.has(obj)) return map.get(obj); // 处理循环引用
  
  const clone = Array.isArray(obj) ? [] : {};
  map.set(obj, clone);
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  return clone;
}
```

### 3. 实现防抖和节流
```javascript
// 防抖：最后一次触发后才执行
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}

// 节流：固定时间内只执行一次
function throttle(fn, delay) {
  let last = 0;
  return function(...args) {
    const now = Date.now();
    if (now - last > delay) {
      fn.apply(this, args);
      last = now;
    }
  };
}
```

### 4. 实现 Promise.all
```javascript
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    const results = [];
    let count = 0;
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        results[index] = value;
        count++;
        if (count === promises.length) {
          resolve(results);
        }
      }).catch(reject);
    });
  });
};
```

### 5. 实现发布订阅模式
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach(cb => cb(...args));
    }
  }
  
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
}
```

## 三、核心知识逻辑图

```
JavaScript 核心机制
├── 数据结构层
│   ├── 原始类型（栈）
│   └── 引用类型（堆）
│       └── 对象 → 原型链 → 继承
│
├── 执行机制层
│   ├── 执行上下文
│   ├── 作用域链
│   └── 闭包（函数+环境）
│
├── 异步机制层
│   ├── 事件循环
│   │   ├── 调用栈
│   │   ├── 微任务队列
│   │   └── 宏任务队列
│   └── Promise（状态机）
│
└── 应用模式层
    ├── 设计模式（发布订阅、单例等）
    └── 性能优化（防抖、节流、缓存）
```

---

**一句话总结：JavaScript 的本质是单线程的事件驱动语言，通过原型链实现对象委托，通过闭包实现状态封装，通过事件循环实现异步非阻塞，所有复杂特性都是这些基础机制的组合应用。**




