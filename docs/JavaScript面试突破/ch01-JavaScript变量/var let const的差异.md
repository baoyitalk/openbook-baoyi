---
sidebar_position: 1
---

# var let const的差异

这是一个基础教程示例。11111

## 介绍

在这个教程中，你将学习到：

- 如何使用本电子书
- 如何查找内容
- 如何参与贡献



## 变量

### 变量的组成有哪些
变量可以看成一个实验室坑位上的萝卜，萝卜上贴的编号就是 变量名， 萝卜的果肉就是变量值；
也可以把变量看成一个工位上的工具盒，变量名就是盒子名称，值就是放在盒子里的东西


![alt text](images/image-1.png)

变量就是一个独立的存储容器 只存储在栈内存
变量名就是对应栈内存的物理地址 无需开发者考虑这个变量本身的物理地址









变量声明  变量提升 变量访问
围绕变量访问展开


![alt text](images/image-2.png)




## 误区1 const声明的变量 严格说不可以重新赋值
重新赋值就要重新开辟一块新堆内存地址

**可以修改引用类型的数据 变量的栈内存携带的堆内存地址不可以更改**


var/let/const的核心差异不是「怎么存储」，而是「变量的可访问范围」「能否修改」「何时销毁」，这些特性间接决定了内存的生命周期和访问权限，具体差异及内存影响如下：
特性维度	var	let	const	对内存的间接影响
作用域	函数级作用域	块级作用域（{}包裹）	块级作用域	变量的栈内存创建 / 释放范围不同：
- var：函数执行时创建，函数执行完毕释放；
- let/const：块执行时（如if/for块）创建，块执行完毕释放
变量提升	存在（声明提升，赋值不提升）	存在「暂时性死区」（提升但不可提前访问）	存在「暂时性死区」	内存创建时机不同：
- var：代码执行前（编译阶段）已在栈内存创建（值为undefined）；
- let/const：代码执行到声明行时，才在栈内存完成初始化
可重新赋值	可以	可以	不可以（只读变量）	对「栈内存存储内容」的修改限制不同：
- var/let：可修改栈中存储的原始值 / 堆地址；
- const：栈中存储的内容不可修改（原始值不可变，堆地址不可变）
可修改引用数据	-	-	可以（仅地址不可改）	对「堆内存数据」的修改无限制：
const obj = {age:25}; obj.age = 26;（栈地址不变，堆中对象属性可改，堆内存占用随修改动态变化）
重复声明	允许	不允许	不允许	避免栈内存中重复创建同名变量容器，减少内存冗余
三、 关键补充：const的内存特性（易混点澄清）



