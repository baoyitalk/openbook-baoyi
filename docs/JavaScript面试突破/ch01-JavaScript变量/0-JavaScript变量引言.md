---
sidebar_position: 0
---

# JavaScript 变量深度解析 - 第一性原理拆解

> 第一章核心内容：var/let/const 差异、作用域、变量提升

---

## 📋 目录

1. [var、let、const 的差异](#一varletconst-的差异)
2. [作用域详解](#二作用域详解)
3. [变量提升机制](#三变量提升机制)
4. [综合面试题实战](#四综合面试题实战)

---

## 一、var、let、const 的差异

### 1.1 第一性原理：为什么会有三种声明方式？

```
本质问题：JavaScript 最初设计只有 var，它有什么缺陷？

var 的历史包袱：
├── 没有块级作用域（只有函数作用域）
├── 变量提升导致代码难以理解
├── 可以重复声明同一变量
└── 全局声明会污染 window 对象

ES6 解决方案：引入 let 和 const
├── let：可变的块级作用域变量
└── const：不可变的块级作用域常量
```

### 1.2 相同点

三者都可以声明变量，都遵循 JavaScript 的标识符命名规则：

```javascript
// 三种方式都可以声明变量
var name = 'Alice';
let age = 25;
const PI = 3.14159;
```

### 1.3 核心差异对比表

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                      var / let / const 差异对比                              │
├──────────┬──────────────┬──────────────┬───────────────┬────────────────────┤
│   特性   │     var      │     let      │    const      │       说明         │
├──────────┼──────────────┼──────────────┼───────────────┼────────────────────┤
│ 定义     │ 声明变量     │ 声明变量     │ 声明常量      │                    │
├──────────┼──────────────┼──────────────┼───────────────┼────────────────────┤
│ 作用域   │ 函数作用域   │ 块级作用域   │ 块级作用域    │ let/const 更精确   │
├──────────┼──────────────┼──────────────┼───────────────┼────────────────────┤
│ 变量提升 │ ✅ 有        │ ❌ 无(TDZ)   │ ❌ 无(TDZ)    │ var 提升易出bug    │
├──────────┼──────────────┼──────────────┼───────────────┼────────────────────┤
│ 重复声明 │ ✅ 允许      │ ❌ 不允许    │ ❌ 不允许     │ let/const 更安全   │
├──────────┼──────────────┼──────────────┼───────────────┼────────────────────┤
│ 重新赋值 │ ✅ 允许      │ ✅ 允许      │ ❌ 不允许     │ const 保护数据     │
├──────────┼──────────────┼──────────────┼───────────────┼────────────────────┤
│ 全局属性 │ ✅ 挂载window│ ❌ 不挂载    │ ❌ 不挂载     │ let/const 不污染   │
└──────────┴──────────────┴──────────────┴───────────────┴────────────────────┘
```

### 1.4 经典面试代码：逐个击破

#### 差异1：暂时性死区（TDZ - Temporal Dead Zone）

```javascript
// var: 变量提升，访问得到 undefined
console.log(a); // undefined
var a = 1;

// let/const: 暂时性死区，报错
console.log(b); // ❌ ReferenceError: Cannot access 'b' before initialization
let b = 2;

console.log(c); // ❌ ReferenceError: Cannot access 'c' before initialization
const c = 3;
```

**TDZ 逻辑图：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    暂时性死区 (TDZ)                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   代码块开始                                                     │
│       │                                                         │
│       ▼                                                         │
│   ┌─────────────────────────────────┐                          │
│   │      暂时性死区 (TDZ)            │  ← 访问变量会报错         │
│   │      let/const 声明的变量        │                          │
│   │      在此区域内不可访问          │                          │
│   └─────────────────────────────────┘                          │
│       │                                                         │
│       ▼  let x = 1; // 声明语句                                 │
│   ┌─────────────────────────────────┐                          │
│   │      安全访问区域                │  ← 可以正常访问           │
│   └─────────────────────────────────┘                          │
│       │                                                         │
│       ▼                                                         │
│   代码块结束                                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 差异2：块级作用域 vs 函数作用域

```javascript
// var: 只有函数作用域，没有块级作用域
if (true) {
  var x = 'var变量';
}
console.log(x); // 'var变量' ✅ 可以访问（泄漏到外部）

// let/const: 有块级作用域
if (true) {
  let y = 'let变量';
  const z = 'const变量';
}
console.log(y); // ❌ ReferenceError: y is not defined
console.log(z); // ❌ ReferenceError: z is not defined
```

#### 差异3：重复声明

```javascript
// var: 允许重复声明（后者覆盖前者）
var name = 'Alice';
var name = 'Bob';  // ✅ 不报错
console.log(name); // 'Bob'

// let: 不允许重复声明
let age = 20;
let age = 25; // ❌ SyntaxError: Identifier 'age' has already been declared

// const: 不允许重复声明
const PI = 3.14;
const PI = 3.14159; // ❌ SyntaxError: Identifier 'PI' has already been declared
```

#### 差异4：全局属性挂载

```javascript
// var: 全局声明会成为 window 的属性
var globalVar = 'I am global';
console.log(window.globalVar); // 'I am global'

// let/const: 不会挂载到 window
let globalLet = 'I am let';
const globalConst = 'I am const';
console.log(window.globalLet);   // undefined
console.log(window.globalConst); // undefined
```

#### 差异5：const 的"不变性"深入理解

```javascript
// const 声明的基本类型：完全不可变
const num = 100;
num = 200; // ❌ TypeError: Assignment to constant variable

// const 声明的引用类型：引用不可变，内容可变！
const person = { name: 'Alice' };
person.name = 'Bob';     // ✅ 可以修改属性
person.age = 25;         // ✅ 可以添加属性
console.log(person);     // `{ name: 'Bob', age: 25 }`

person = { name: 'Charlie' }; // ❌ TypeError: 不能重新赋值

// 如果要让对象完全不可变，使用 Object.freeze()
const frozen = Object.freeze({ name: 'Alice' });
frozen.name = 'Bob';     // 静默失败（严格模式下报错）
console.log(frozen.name); // 'Alice'
```

**const 不变性逻辑图：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    const 的"不变性"本质                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   const 保证的是：变量指向的【内存地址】不变                      │
│                                                                 │
│   基本类型：                          引用类型：                 │
│   ┌─────────────┐                    ┌─────────────┐            │
│   │ const n = 1 │                    │const obj={} │            │
│   └──────┬──────┘                    └──────┬──────┘            │
│          │                                  │                   │
│          ▼                                  ▼                   │
│   ┌─────────────┐                    ┌─────────────┐            │
│   │  值: 1      │ ← 不可变           │ 地址: 0x001 │ ← 不可变   │
│   └─────────────┘                    └──────┬──────┘            │
│                                             │                   │
│                                             ▼                   │
│                                      ┌─────────────┐            │
│                                      │ 堆内存对象  │ ← 可以修改 │
│                                      │ {name:'Bob'}│            │
│                                      └─────────────┘            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 1.5 使用建议

```
┌─────────────────────────────────────────────────────────────────┐
│                    最佳实践建议                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   优先级：const > let > var                                     │
│                                                                 │
│   ┌────────────────────────────────────────────────────────┐   │
│   │ 1. 默认使用 const                                       │   │
│   │    - 大多数变量声明后不需要重新赋值                      │   │
│   │    - 明确表达"这个值不应该被改变"的意图                  │   │
│   └────────────────────────────────────────────────────────┘   │
│                           │                                     │
│                           ▼                                     │
│   ┌────────────────────────────────────────────────────────┐   │
│   │ 2. 需要重新赋值时使用 let                                │   │
│   │    - 循环计数器: for (let i = 0; ...)                   │   │
│   │    - 需要条件赋值的变量                                  │   │
│   └────────────────────────────────────────────────────────┘   │
│                           │                                     │
│                           ▼                                     │
│   ┌────────────────────────────────────────────────────────┐   │
│   │ 3. 避免使用 var                                         │   │
│   │    - 只在维护旧代码时使用                                │   │
│   │    - 新代码完全不需要 var                                │   │
│   └────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 二、作用域详解

### 2.1 第一性原理：什么是作用域？

```
本质问题：变量在哪里可以被访问？

作用域 = 变量的可访问范围 = 代码的执行环境

为什么需要作用域？
├── 避免命名冲突（不同作用域可以有同名变量）
├── 内存管理（离开作用域后变量可被回收）
├── 安全性（限制变量的可访问范围）
└── 模块化（实现代码隔离）
```

### 2.2 静态作用域 vs 动态作用域

```javascript
// JavaScript 采用【静态作用域】（词法作用域）
// 作用域在代码编写时就确定了，而不是运行时

var value = 1;

function foo() {
  console.log(value); // 静态作用域：查找定义时的外层作用域
}

function bar() {
  var value = 2;
  foo();
}

bar(); // 输出 1（不是 2！）

// 解释：
// foo 定义在全局，它的外层作用域是全局作用域
// 即使在 bar 中调用，foo 仍然访问全局的 value
```

**静态作用域 vs 动态作用域对比：**

```
┌─────────────────────────────────────────────────────────────────┐
│              静态作用域 vs 动态作用域                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   静态作用域（JavaScript）           动态作用域（Bash等）       │
│   ─────────────────────────          ─────────────────────      │
│   作用域在【定义时】确定              作用域在【调用时】确定      │
│   查找变量沿定义位置向外查找          查找变量沿调用栈向上查找    │
│                                                                 │
│   var value = 1;                     value=1                    │
│   function foo() {                   foo() {                    │
│     console.log(value);                echo $value              │
│   }                                  }                          │
│   function bar() {                   bar() {                    │
│     var value = 2;                     local value=2            │
│     foo(); // 输出 1                    foo  # 输出 2            │
│   }                                  }                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 JavaScript 作用域类型

```
┌─────────────────────────────────────────────────────────────────┐
│                 JavaScript 作用域层次                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │                    全局作用域                            │  │
│   │   • 最外层定义的变量                                     │  │
│   │   • 任何位置都可访问                                     │  │
│   │   • var 声明会挂载到 window                              │  │
│   │                                                         │  │
│   │   ┌─────────────────────────────────────────────────┐  │  │
│   │   │              函数作用域                          │  │  │
│   │   │   • function 内部定义的变量                      │  │  │
│   │   │   • 只能在函数内部访问                           │  │  │
│   │   │   • var 只有函数作用域                           │  │  │
│   │   │                                                 │  │  │
│   │   │   ┌─────────────────────────────────────────┐  │  │  │
│   │   │   │          块级作用域 (ES6+)              │  │  │  │
│   │   │   │   • {} 内部定义的 let/const 变量        │  │  │  │
│   │   │   │   • if/for/while 等代码块               │  │  │  │
│   │   │   │   • var 没有块级作用域！                │  │  │  │
│   │   │   └─────────────────────────────────────────┘  │  │  │
│   │   └─────────────────────────────────────────────────┘  │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│   另外还有：                                                    │
│   • 模块作用域：ES6 Module 中，每个模块有独立作用域             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.4 作用域类型详解与代码示例

#### 全局作用域

```javascript
// 全局作用域中的变量
var globalVar = 'global';
let globalLet = 'global let';
const globalConst = 'global const';

// 全局函数
function globalFunction() {
  console.log(globalVar); // 可以访问全局变量
}

// 注意：var 会污染 window
console.log(window.globalVar);   // 'global'
console.log(window.globalLet);   // undefined（let 不挂载）
```

#### 函数作用域

```javascript
function outer() {
  var functionScoped = 'only in function';
  
  function inner() {
    console.log(functionScoped); // ✅ 内层函数可以访问外层变量
  }
  
  inner();
}

outer();
console.log(functionScoped); // ❌ ReferenceError: functionScoped is not defined
```

#### 块级作用域

```javascript
// if 块
if (true) {
  var varInBlock = 'var';     // var 没有块级作用域
  let letInBlock = 'let';     // let 有块级作用域
  const constInBlock = 'const'; // const 有块级作用域
}
console.log(varInBlock);   // 'var' ✅
console.log(letInBlock);   // ❌ ReferenceError
console.log(constInBlock); // ❌ ReferenceError

// for 循环 - 经典面试题！
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log('var:', i), 100);
}
// 输出: var: 3, var: 3, var: 3 （都是3！）

for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log('let:', j), 100);
}
// 输出: let: 0, let: 1, let: 2 ✅
```

**for 循环作用域问题图解：**

```
┌─────────────────────────────────────────────────────────────────┐
│                  for 循环中 var vs let                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   使用 var:                          使用 let:                  │
│   ──────────                         ──────────                 │
│   var i 在函数作用域                  每次迭代创建新的块作用域    │
│                                                                 │
│   ┌─────────────────────┐            ┌─────────────────────┐   │
│   │  函数作用域          │            │  迭代 0: let j = 0  │   │
│   │  var i = 0,1,2,3    │            ├─────────────────────┤   │
│   │                     │            │  迭代 1: let j = 1  │   │
│   │  setTimeout 回调    │            ├─────────────────────┤   │
│   │  都访问同一个 i     │            │  迭代 2: let j = 2  │   │
│   │  循环结束时 i = 3   │            └─────────────────────┘   │
│   └─────────────────────┘            每个回调捕获自己的 j       │
│                                                                 │
│   结果: 3, 3, 3                      结果: 0, 1, 2              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.5 作用域链

```javascript
// 作用域链：由内向外查找变量的链条
var a = 1;

function outer() {
  var b = 2;
  
  function inner() {
    var c = 3;
    console.log(a, b, c); // 1, 2, 3
    // 查找顺序: inner作用域 -> outer作用域 -> 全局作用域
  }
  
  inner();
}

outer();
```

**作用域链图解：**

```
┌─────────────────────────────────────────────────────────────────┐
│                       作用域链查找过程                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   console.log(a, b, c) 的查找过程：                             │
│                                                                 │
│   ┌──────────────────┐                                         │
│   │  inner 作用域    │  ← 查找 c ✅ 找到                        │
│   │  c = 3           │  ← 查找 b ❌ 没找到，向上                │
│   └────────┬─────────┘  ← 查找 a ❌ 没找到，向上                │
│            │                                                    │
│            ▼                                                    │
│   ┌──────────────────┐                                         │
│   │  outer 作用域    │  ← 查找 b ✅ 找到                        │
│   │  b = 2           │  ← 查找 a ❌ 没找到，向上                │
│   └────────┬─────────┘                                         │
│            │                                                    │
│            ▼                                                    │
│   ┌──────────────────┐                                         │
│   │  全局作用域       │  ← 查找 a ✅ 找到                        │
│   │  a = 1           │                                         │
│   └──────────────────┘                                         │
│                                                                 │
│   如果全局也没有 → ReferenceError: xxx is not defined           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 2.6 模块作用域

```javascript
// ES6 模块作用域
// moduleA.js
const privateVar = 'private';  // 模块内私有
export const publicVar = 'public';  // 导出后才能外部访问

// moduleB.js
import { publicVar } from './moduleA.js';
console.log(publicVar);   // 'public'
console.log(privateVar);  // ❌ ReferenceError
```

---

## 三、变量提升机制

### 3.1 第一性原理：为什么会有变量提升？

```
本质问题：JavaScript 引擎是如何执行代码的？

JavaScript 执行分两个阶段：
1. 创建阶段（编译阶段）
   - 创建执行上下文
   - 扫描代码，将 var 和 function 声明提升到顶部
   - 建立作用域链
   
2. 执行阶段
   - 逐行执行代码
   - 变量赋值
   - 函数调用

变量提升就发生在"创建阶段"
```

```
┌─────────────────────────────────────────────────────────────────┐
│                  JavaScript 代码执行的两个阶段                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│         编译阶段                          执行阶段               │
│        (准备工作)                        (真正干活)              │
│            │                                │                   │
│            ▼                                ▼                   │
│    ┌───────────────┐                ┌───────────────┐          │
│    │  1.创建作用域  │                │ 逐行执行代码   │          │
│    │ (全局/函数/块) │                │               │          │
│    ├───────────────┤                │  • 变量赋值   │          │
│    │  2.登记声明    │                │  • 函数调用   │          │
│    │ (var/let/     │                │  • 表达式计算 │          │
│    │  const/func)  │                │               │          │
│    └───────┬───────┘                └───────┬───────┘          │
│            │                                │                   │
│            └────────────┬───────────────────┘                   │
│                         ▼                                       │
│              ┌─────────────────────┐                           │
│              │   作用域链（记录本）  │                           │
│              │                     │                           │
│              │ 查找变量：           │                           │
│              │ 当前 → 父级 → 全局   │                           │
│              └─────────────────────┘                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

```

### 3.2 var 的变量提升

```javascript
// 我们写的代码
console.log(counter); // undefined（不是报错！）
var counter = 1;

// JavaScript 引擎理解为
var counter;           // 声明被提升到顶部
console.log(counter);  // undefined
counter = 1;           // 赋值留在原地
```

### 3.3 function 的函数提升

```javascript
// 函数声明会完整提升（包括函数体）
sayHello(); // ✅ 'Hello!'

function sayHello() {
  console.log('Hello!');
}

// 函数表达式不会提升函数体！
sayBye(); // ❌ TypeError: sayBye is not a function

var sayBye = function() {
  console.log('Bye!');
};

// 相当于
var sayBye;        // 只提升了变量声明
sayBye();          // undefined() → TypeError
sayBye = function() { ... };
```

**函数提升 vs 变量提升：**

```
┌─────────────────────────────────────────────────────────────────┐
│               函数声明 vs 函数表达式 提升对比                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   函数声明 (Function Declaration)                               │
│   ────────────────────────────────                              │
│   function foo() { ... }                                        │
│                                                                 │
│   提升结果：整个函数都提升                                       │
│   ┌─────────────────────────────┐                              │
│   │ function foo() { ... }      │  ← 完整提升                  │
│   └─────────────────────────────┘                              │
│                                                                 │
│   函数表达式 (Function Expression)                              │
│   ────────────────────────────────                              │
│   var bar = function() { ... }                                  │
│                                                                 │
│   提升结果：只提升变量声明                                       │
│   ┌─────────────────────────────┐                              │
│   │ var bar;                    │  ← 只提升声明，值为undefined │
│   │ ...                         │                              │
│   │ bar = function() { ... }    │  ← 赋值留在原地              │
│   └─────────────────────────────┘                              │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.4 let/const 没有变量提升？—— 准确说法

```javascript
// let/const 实际上也有"提升"，但处于 TDZ 中
console.log(x); // ❌ ReferenceError: Cannot access 'x' before initialization
let x = 1;

// 更准确的说法：
// let/const 声明被提升了，但没有初始化
// 在声明语句之前访问会触发 TDZ 错误
```

### 3.5 同名变量和函数的提升优先级

```javascript
// 当变量名和函数名相同时，函数声明优先级更高
let x = 20,
    y = 10;

let result = add(x, y);
console.log("result: " + result); // "result: 60"

var add = function(a, b) {
  return a + b;  // 这个不会执行
}

function add(a) {
  return a + 40; // 这个会执行
}

// 提升后的代码：
// function add(a) { return a + 40; }  ← 函数声明提升
// var add;                             ← 变量声明提升（但不覆盖函数）
// let x = 20, y = 10;
// let result = add(x, y);              ← 调用的是函数 add(20) = 60
// add = function(a, b) { ... }         ← 之后才赋值
```

**提升优先级规则：**

```
┌─────────────────────────────────────────────────────────────────┐
│                    提升优先级规则                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 函数声明 > 变量声明                                        │
│      - 同名时，函数声明不会被变量声明覆盖                       │
│      - 但会被变量赋值覆盖                                       │
│                                                                 │
│   2. 同名函数声明，后者覆盖前者                                  │
│                                                                 │
│   3. let/const 在 TDZ 中，不参与提升优先级讨论                  │
│                                                                 │
│   执行顺序：                                                    │
│   ┌─────────────────────────────────────────────────────────┐  │
│   │ ① 所有函数声明提升（整体提升）                           │  │
│   │ ② 所有 var 变量声明提升（值为 undefined）                │  │
│   │ ③ 按顺序执行代码（赋值、调用等）                         │  │
│   └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3.6 经典面试题：预测输出

```javascript
// 面试题1
console.log(a); // ?
var a = 1;
function a() {}
console.log(a); // ?

// 答案：
// function a() {}  （函数声明优先）
// 1               （被赋值覆盖）
```

```javascript
// 面试题2
var a = 1;
function foo() {
  console.log(a); // ?
  var a = 2;
  console.log(a); // ?
}
foo();

// 答案：
// undefined  （函数内的 var a 提升）
// 2         （赋值后）
```

```javascript
// 面试题3
function foo() {
  console.log(a);
  console.log(bar());
  
  var a = 'hello';
  function bar() {
    return 'world';
  }
}
foo();

// 答案：
// undefined    （var a 提升但未赋值）
// 'world'      （function bar 完整提升）
```

---

## 四、综合面试题实战

### 4.1 经典闭包 + 作用域题

```javascript
// 问题：如何让下面代码输出 0, 1, 2？
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}
// 实际输出: 3, 3, 3

// 解法1: 使用 let
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i);
  }, 100);
}

// 解法2: 使用 IIFE（立即执行函数）
for (var i = 0; i < 3; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j);
    }, 100);
  })(i);
}

// 解法3: 使用 setTimeout 第三个参数
for (var i = 0; i < 3; i++) {
  setTimeout(function(j) {
    console.log(j);
  }, 100, i);
}
```

### 4.2 综合提升题

```javascript
// 预测以下代码输出
console.log(foo);

function foo() {
  console.log('foo1');
}

var foo = 1;

function foo() {
  console.log('foo2');
}

console.log(foo);

// 分析提升后的代码：
// function foo() { console.log('foo1'); }
// function foo() { console.log('foo2'); }  // 后面的函数覆盖前面的
// var foo;  // 变量声明不覆盖函数
// console.log(foo);  // [Function: foo]（打印 foo2 那个函数）
// foo = 1;
// console.log(foo);  // 1

// 答案：
// [Function: foo]
// 1
```

### 4.3 作用域链综合题

```javascript
var x = 10;

function foo() {
  console.log(x);
}

function bar() {
  var x = 20;
  foo();
}

bar(); // 输出 10（静态作用域）

// 变体题
var x = 10;

function bar() {
  var x = 20;
  function foo() {
    console.log(x);
  }
  foo();
}

bar(); // 输出 20（foo 定义在 bar 内部）
```

---

## 🎯 核心奥义（一句话总结）

> **JavaScript 变量的本质是「声明方式决定作用域，作用域决定生命周期，而提升机制是引擎执行的副产物」—— 理解了 var 的函数作用域导致的问题、let/const 的块级作用域如何解决这些问题、以及静态作用域链的查找机制，你就掌握了 JavaScript 变量系统的第一性原理。**

---

## 📚 速查表

| 知识点 | 核心要点 | 面试高频问法 |
|--------|----------|-------------|
| var | 函数作用域、变量提升、可重复声明 | var 有什么问题？ |
| let | 块级作用域、TDZ、不可重复声明 | let 和 var 的区别？ |
| const | 块级作用域、声明时必须赋值、不可重新赋值 | const 定义的对象能修改吗？ |
| 作用域 | 全局/函数/块级/模块 | 什么是作用域链？ |
| 变量提升 | var/function 声明提升到顶部 | 什么是变量提升？ |
| TDZ | let/const 声明前的死区 | 什么是暂时性死区？ |
| 静态作用域 | 作用域在定义时确定 | JS 是静态还是动态作用域？ |

---

## 🔗 关键概念速记

```
var    → 会提升 → 函数作用域 → 可重复声明 → 挂载 window
let    → TDZ    → 块级作用域 → 不可重复   → 不挂载
const  → TDZ    → 块级作用域 → 不可重复   → 不可重新赋值（引用内容可变）

作用域链 = 由内向外查找
静态作用域 = 定义时确定（不是调用时）
变量提升 = 创建阶段的产物
```

---

*最后更新：基于 ES6+ 标准整理*
