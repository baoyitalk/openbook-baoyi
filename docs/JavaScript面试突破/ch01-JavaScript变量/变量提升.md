# 变量提升



## 概述

### 变量提升的历史背景

弱类型+动态执行

var变量提升：编译阶段完成「创建 + 初始化」，初始值为undefined，执行阶段才赋值；
函数声明提升：编译阶段完成「创建 + 初始化 + 赋值」，初始值是完整函数体，可直接提前调用；
核心差异：var编译阶段只给 “空值（undefined）”，函数声明编译阶段直接给 “完整功能（函数体）”。
简单记：编译阶段，var是 “占位置但空着手”，函数声明是 “占位置还带好了工具（函数体）”

JavaScript 诞生于 1995 年，设计目标是 “轻量、快速、适配浏览器动态场景”，核心特点是弱类型、动态执行：
弱类型：变量可以随时改类型（var a = 10; a = 'hello';），编译阶段无法确定变量最终是什么类型 / 值；
动态执行：代码可能在运行时动态生成（比如eval('var c = 20')），编译阶段根本感知不到这些动态逻辑。
在这种背景下，把var的 “声明” 和 “赋值” 拆成两个阶段是最合理的选择：



总结
本质差异：函数是 “静态定义”（编译阶段就能确定值），变量是 “动态赋值”（依赖运行时逻辑），所以var只能提升声明，无法提升赋值；
历史背景：JavaScript 早期为了适配 “弱类型、动态执行”，必须把声明和赋值分离，undefined是 “已声明未赋值” 的合理标记；
设计权衡：如果var编译阶段直接可用，会失去动态语言的灵活性，还会导致依赖运行时的赋值逻辑无法执行。




## 案例1
同名变量和函数提升，后面的会覆盖前面的，因此执行的是最后一个函数 add

```js

let x = 20,
    y = 10;


let result = add(x);
console.log('result1:' + result); 



function add(a) { // 函数声明 编译阶段就是完整的声明+赋值
    return a + 40
}

function add(b) { // 后面的会覆盖前面的， 函数声明的优先级更高
    return b + 30
}

var add = function(a, b) { // 编译阶段var 声明 提升了声明 但不会提升赋值 
    return a + b
}

```

打印结果依然是 50，变量名相同 ，同样是变量提升，函数声明优先级比var声明更高

引擎会先扫描所有声明，按优先级处理：
函数声明优先提升：所有function add() {}会被整体提升到当前作用域顶部，且后声明的函数会覆盖先声明的；
var 声明提升：var add会被提升，但因为和函数声明同名，且函数提升优先级更高，所以var add的提升无实际效果（相当于 “占位但不改变值”）；
let 声明不提升：let x=20, y=10; let result; 不会提升，且存在「暂时性死区」，编译阶段只标记 “有这些变量”，不初始化。
编译阶段结束后，作用域里的add指向的是第二个函数声明


