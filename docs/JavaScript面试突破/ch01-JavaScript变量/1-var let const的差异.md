---
sidebar_position: 1
---



# 1-变量的组成有哪些
变量可以看成一个实验室坑位上的萝卜，萝卜上贴的编号就是 变量名， 萝卜的果肉就是变量值；
也可以把变量看成一个工位上的工具盒，变量名就是盒子名称，值就是放在盒子里的东西

**变量是独立的存储空间，是存放在栈内存的**


![alt text](images/image-1.png)

变量就是一个独立的存储容器 只存储在栈内存
变量名就是对应栈内存的物理地址 无需开发者考虑这个变量本身的物理地址









变量声明  变量提升 变量访问
围绕变量访问展开


![alt text](images/image-2.png)
# 2-const修饰的变量绑定关系不可变

## 概述
var修饰的变量 可以 更换 变量与堆内存地址的绑定关系，重新赋值就会在堆内存
重新开辟一块空间


## 案例1


```js
// 案例1 以下代码输出结果是什么

const obj = { prop: 0 };

obj.prop = obj.prop + 1;

console.log(obj.prop); // 1. 打印结果是什么?

obj = {}; // 2. 执行结果是什么?
```
![[Pasted image 20260112110033.png]]
##  误区1 
const声明的变量 严格说不可以重新赋值
重新赋值就要重新开辟一块新堆内存地址

**可以修改引用类型的数据 变量的栈内存携带的堆内存地址不可以更改**


变量名与 堆内存地址的绑定是不可变的 这是最严谨说法
变量只能存在栈内存，栈内存存放7种原始数据类型， 堆内存存放引用数据类型
![[Pasted image 20260112105729.png]]




补充资料：
var/let/const的核心差异不是「怎么存储」，而是「变量的可访问范围」「能否修改」「何时销毁」，这些特性间接决定了内存的生命周期和访问权限，具体差异及内存影响如下：
特性维度	var	let	const	对内存的间接影响
作用域	函数级作用域	块级作用域（{}包裹）	块级作用域	变量的栈内存创建 / 释放范围不同：
- var：函数执行时创建，函数执行完毕释放；
- let/const：块执行时（如if/for块）创建，块执行完毕释放
变量提升	存在（声明提升，赋值不提升）	存在「暂时性死区」（提升但不可提前访问）	存在「暂时性死区」	内存创建时机不同：
- var：代码执行前（编译阶段）已在栈内存创建（值为undefined）；
- let/const：代码执行到声明行时，才在栈内存完成初始化
可重新赋值	可以	可以	不可以（只读变量）	对「栈内存存储内容」的修改限制不同：
- var/let：可修改栈中存储的原始值 / 堆地址；
- const：栈中存储的内容不可修改（原始值不可变，堆地址不可变）
可修改引用数据	-	-	可以（仅地址不可改）	对「堆内存数据」的修改无限制：
const obj = {age:25}; obj.age = 26;（栈地址不变，堆中对象属性可改，堆内存占用随修改动态变化）
重复声明	允许	不允许	不允许	避免栈内存中重复创建同名变量容器，减少内存冗余
三、 关键补充：const的内存特性（易混点澄清）



