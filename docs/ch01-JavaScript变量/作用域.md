---
sidebar_position: 3
---

# 作用域


## 为什么需要作用域

假设没有作用域所有变量都是全局的

```js
var a = 1;

function foo() {
  var a = 2;  // 这会覆盖外面的 a
}

foo();
console.log(a);  // 2 —— 被污染了！
```



## 作用域是怎么工作的





### 先看个经典面试题

```js
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 输出：3, 3, 3

```

100ms后 3个定时器同时执行，去读取i
![alt text](images/image-4.png)


![alt text](images/image-3.png)




### 为什么let会输出 0 1 2




let声明的变量不是全局变量 被 for循环（）代码块限制了let的作用域
var i也是写在for循环的()这个代码块里，但关键就在于：var完全无视「代码块」的作用域限制，而let会严格遵守「代码块」的作用域限制，这是两者最本质的区别。
先把核心逻辑讲透
JavaScript 里的「作用域限制规则」对var和let是两套完全不同的规则：
对var来说：只有函数体（function(){}）能限制它的作用域，任何代码块（for()/if(){}/{}）都不行；
对let来说：任何代码块（包括for()/if(){}/{}）都能限制它的作用域，普通的小括号只是运算优先级不创建作用域
![alt text](images/image-5.png)





## 函数作用域

函数内声明的变量，只能在函数作用域范围内访问

var只会认函数作用域其他的 花括号 代码块不认的 只认函数的花括号





## 作用域的本质

1.作用域 ----------- 变量住在哪个房间

2.作用域链 --------- 程序找变量时从里往外找的路径

3.var ------------- 房间的边界是函数 只认函数的花括号{}

4.let/const ------- 房间的边界是花括号 {}




