## 第一性原理拆解：JavaScript 运行时

### 核心问题：JavaScript 代码是如何被执行的？

---

## 一、执行上下文（Execution Context）

### 本质：代码执行时的环境

```
┌─────────────────────────────────────────────────────────┐
│  JavaScript 引擎执行代码时，会创建执行上下文            │
├─────────────────────────────────────────────────────────┤
│  三种类型：                                             │
│  • 全局执行上下文（只有一个，浏览器中是 window）        │
│  • 函数执行上下文（每次调用函数都会创建）               │
│  • eval 执行上下文（不推荐使用）                        │
└─────────────────────────────────────────────────────────┘
```

### 执行上下文的两个阶段

```javascript
let x = 10;
function timesTen(a) {
    return a * 10;
}
let y = timesTen(x);
console.log(y);  // 100
```

**阶段一：创建阶段**

```
┌─────────────────────────────────┐
│      全局执行上下文 - 创建阶段   │
├─────────────────────────────────┤
│  全局对象: window               │
│  this: window                   │
│  x: undefined    ← 变量提升     │
│  y: undefined    ← 变量提升     │
│  timesTen: function(){...}      │
└─────────────────────────────────┘
```

**阶段二：执行阶段**

```
┌─────────────────────────────────┐
│      全局执行上下文 - 执行阶段   │
├─────────────────────────────────┤
│  全局对象: window               │
│  this: window                   │
│  x: 10          ← 赋值          │
│  y: 100         ← 函数返回值    │
│  timesTen: function(){...}      │
└─────────────────────────────────┘
```

### 调用栈（Call Stack）

```javascript
function first() {
    console.log('first');
    second();
}
function second() {
    console.log('second');
    third();
}
function third() {
    console.log('third');
}
first();

// 调用栈变化：
// [global] → [global, first] → [global, first, second] 
// → [global, first, second, third] → 依次弹出
```

---

## 二、垃圾回收（Garbage Collection）

### 内存生命周期

```
分配内存 → 使用内存 → 释放内存
```

### 1. 引用计数法（早期，已淘汰）

```javascript
let o1 = { a: { b: 2 } };
let o2 = o1;  // o2 引用 o1

o2 = 1;
o1 = null;    // { a: { b: 2 } } 引用计数变为 0，可回收
```

**致命缺陷：循环引用**

```javascript
function f() {
    var o1 = {};
    var o2 = {};
    o1.a = o2;  // o1 引用 o2
    o2.a = o1;  // o2 引用 o1
    return 'done';
}
f();
// o1 和 o2 互相引用，引用计数永远不为 0，无法回收！
```

### 2. 标记清除法（现代浏览器使用）

```
┌─────────────────────────────────────────────────────────┐
│  从根对象（window/global）开始，标记所有可达的对象       │
│  ↓                                                      │
│  未被标记的对象 = 不可达 = 垃圾                          │
│  ↓                                                      │
│  清除所有未标记的对象，释放内存                          │
└─────────────────────────────────────────────────────────┘
```

### V8 引擎优化策略

| 策略 | 说明 |
|------|------|
| 分代收集 | 新生代（短命对象）+ 老生代（长寿对象）分别处理 |
| 增量收集 | 分批次处理，避免长时间阻塞 |
| 空闲收集 | CPU 空闲时执行 |

---

## 三、判断运行环境

```javascript
// 浏览器环境
let isBrowser = typeof window !== 'undefined' 
    && Object.prototype.toString.call(window) === '[object Window]';

// Node.js 环境
let isNode = typeof global !== 'undefined' 
    && Object.prototype.toString.call(global) === '[object global]';

// 通用判断
let isNodeEnv = typeof process !== 'undefined' 
    && process.versions && process.versions.node;
```

### 浏览器 vs Node.js

| 特性 | 浏览器 | Node.js |
|------|--------|---------|
| 全局对象 | `window` | `global` |
| 顶级 `var` | 挂载到 `window` | 模块局部变量 |
| 顶级 `this` | `window` | `module.exports` |
| DOM API | ✅ 有 | ❌ 没有 |
| 文件系统 | ❌ 没有 | ✅ 有 |

---

## 四、事件循环（Event Loop）— 核心中的核心

### 为什么需要事件循环？

```
JavaScript 是单线程的
↓
如果遇到耗时操作（网络请求、定时器）就会阻塞
↓
事件循环解决了这个问题：异步任务不阻塞主线程
```

### 事件循环模型

```
┌───────────────────────────────────────────────────────────┐
│                     Event Loop                            │
├───────────────────────────────────────────────────────────┤
│                                                           │
│   ┌─────────────┐                                         │
│   │  Call Stack │  ← 执行同步代码                          │
│   └─────────────┘                                         │
│          ↑                                                │
│          │ 从队列取任务                                    │
│          │                                                │
│   ┌──────┴────────────────────────────────────┐           │
│   │                                           │           │
│   │  ┌─────────────────┐  ┌───────────────┐  │           │
│   │  │ 微任务队列       │  │ 宏任务队列    │  │           │
│   │  │ (Microtask)     │  │ (Macrotask)   │  │           │
│   │  │ • Promise.then  │  │ • setTimeout  │  │           │
│   │  │ • queueMicrotask│  │ • setInterval │  │           │
│   │  │ • MutationObs.. │  │ • I/O         │  │           │
│   │  │                 │  │ • UI 渲染     │  │           │
│   │  └─────────────────┘  └───────────────┘  │           │
│   └───────────────────────────────────────────┘           │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

### 执行顺序

```
1. 执行同步代码（调用栈）
2. 调用栈清空后，执行所有微任务
3. 微任务清空后，执行一个宏任务
4. 重复 2-3
```

### 经典面试代码

```javascript
console.log(1);

setTimeout(() => {
    console.log(2);
}, 0);

Promise.resolve().then(() => {
    console.log(3);
});

console.log(4);

// 输出顺序：1, 4, 3, 2
// 分析：
// 1. 同步：console.log(1)
// 2. 宏任务：setTimeout 回调入队
// 3. 微任务：Promise.then 入队
// 4. 同步：console.log(4)
// 5. 调用栈空，执行微任务：console.log(3)
// 6. 微任务空，执行宏任务：console.log(2)
```

### 更复杂的例子

```javascript
console.log('script start');

setTimeout(() => {
    console.log('setTimeout');
}, 0);

Promise.resolve()
    .then(() => {
        console.log('promise1');
    })
    .then(() => {
        console.log('promise2');
    });

console.log('script end');

// 输出：
// script start
// script end
// promise1
// promise2
// setTimeout
```

### async/await 的事件循环

```javascript
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');  // 相当于放入微任务队列
}

async function async2() {
    console.log('async2');
}

console.log('script start');
setTimeout(() => console.log('setTimeout'), 0);
async1();
new Promise(resolve => {
    console.log('promise1');
    resolve();
}).then(() => {
    console.log('promise2');
});
console.log('script end');

// 输出：
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout
```

---

## 五、内存泄漏

### 常见原因

| 类型 | 示例 | 解决方案 |
|------|------|----------|
| 隐式全局变量 | `bar = 'leak'` | 使用 `'use strict'` |
| 未清除的定时器 | `setInterval` | 组件销毁时 `clearInterval` |
| 游离的 DOM 引用 | 删除 DOM 但变量仍引用 | 手动置为 `null` |
| 闭包 | 闭包持有大对象 | 及时解除引用 |

### 示例代码

```javascript
// 1. 隐式全局变量
function foo() {
    bar = 'leak';  // 没有声明，变成全局变量
}

// 2. 未清除的定时器
const timer = setInterval(() => {
    const node = document.getElementById('Node');
    if (node) {
        node.innerHTML = JSON.stringify(someData);
    }
}, 1000);
// 解决：clearInterval(timer)

// 3. 游离 DOM
let button = document.getElementById('button');
function removeButton() {
    document.body.removeChild(button);
    // button 变量仍然引用着这个 DOM
}
// 解决：button = null

// 4. 闭包泄漏
function outer() {
    const bigData = new Array(1000000).fill('*');
    return function inner() {
        console.log(bigData.length);
    };
}
const leak = outer();  // bigData 无法被回收
```

---

## 六、本地存储

| 存储方式 | 大小限制 | 生命周期 | 适用场景 |
|----------|----------|----------|----------|
| Cookie | ~4KB | 可设过期时间 | 用户身份、追踪 |
| localStorage | ~5MB | 永久 | 长期数据、草稿 |
| sessionStorage | ~5MB | 页面关闭即删 | 敏感临时数据 |
| IndexedDB | 无限制 | 永久 | 大量结构化数据 |

### 使用示例

```javascript
// localStorage
localStorage.setItem('name', 'John');
localStorage.getItem('name');  // 'John'
localStorage.removeItem('name');
localStorage.clear();

// sessionStorage（API 相同）
sessionStorage.setItem('token', 'abc123');

// Cookie
document.cookie = 'name=John; max-age=3600; path=/';

// IndexedDB（异步）
const request = indexedDB.open('myDB', 1);
request.onsuccess = (e) => {
    const db = e.target.result;
    // 操作数据库...
};
```

---

## 总结

```
┌─────────────────────────────────────────────────────────────────┐
│                    JavaScript 运行时核心                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  执行上下文                                                     │
│  ├── 创建阶段：变量提升、确定 this、创建作用域链                │
│  ├── 执行阶段：变量赋值、执行代码                               │
│  └── 调用栈：后进先出，管理执行上下文                           │
│                                                                 │
│  垃圾回收                                                       │
│  ├── 引用计数（淘汰）：循环引用问题                             │
│  └── 标记清除（现代）：从根出发，标记可达对象                   │
│                                                                 │
│  事件循环（核心）                                               │
│  ├── 同步代码 → 微任务 → 宏任务 → 微任务 → 宏任务...            │
│  ├── 微任务：Promise.then, queueMicrotask                       │
│  └── 宏任务：setTimeout, setInterval, I/O                       │
│                                                                 │
│  内存泄漏                                                       │
│  ├── 隐式全局变量                                               │
│  ├── 未清除定时器                                               │
│  ├── 游离 DOM 引用                                              │
│  └── 闭包持有大对象                                             │
│                                                                 │
│  本地存储                                                       │
│  ├── Cookie（4KB，可设过期）→ 身份认证                          │
│  ├── localStorage（5MB，永久）→ 长期数据                        │
│  ├── sessionStorage（5MB，会话）→ 临时数据                      │
│  └── IndexedDB（无限，异步）→ 大量数据                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**核心记忆：执行上下文管代码执行，事件循环管异步顺序，垃圾回收管内存释放。**