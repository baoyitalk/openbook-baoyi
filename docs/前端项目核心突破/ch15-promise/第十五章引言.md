# Promise 的用法 - 第一性原理完全指南

> 🎯 **面试高频指数：★★★★★**

---

## 📚 目录

1. [第一性原理：什么是 Promise？](#第一性原理什么是-promise)
2. [Promise 基本用法](#promise-基本用法)
3. [实例方法详解](#实例方法详解)
4. [静态方法详解](#静态方法详解)
5. [手撕代码大全](#手撕代码大全)
6. [核心奥义](#核心奥义)

---

## 第一性原理：什么是 Promise？

### 🧠 从回调地狱说起

**回调方法**：就是将一个方法 func2 作为参数传入另一个方法 func1 中，当 func1 执行到某一步或者满足某种条件的时候才执行传入的参数 func2

```javascript
// 回调地狱示例
getData1(function(result1) {
    getData2(result1, function(result2) {
        getData3(result2, function(result3) {
            getData4(result3, function(result4) {
                // 嵌套越来越深...
                console.log(result4);
            });
        });
    });
});
```

### 💡 Promise 的诞生

**Promise 是 ES6 引入的异步编程的新解决方案。**

#### 🎭 生动比喻：求婚的故事

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   你跟你女朋友求婚，她跟你说她要考虑一下，明天才能给你答案        │
│                                                                 │
│   这就是【承诺 (Promise)】                                       │
│                                                                 │
│   同时，这也是一个等待的【过程 (pending)】                        │
│                                                                 │
│   然后你就等，等到明天你女朋友给你答复：                          │
│                                                                 │
│   ├─→ 同意 (resolved/fulfilled) → 准备结婚了 ✓                  │
│   │                                                             │
│   └─→ 拒绝 (rejected) → 等下次再求婚 ✗                          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 📊 Promise 三种状态

```
                    ┌─────────────────┐
                    │                 │
                    │    pending      │
                    │   (进行中)       │
                    │                 │
                    └────────┬────────┘
                             │
              ┌──────────────┴──────────────┐
              │                             │
              ↓                             ↓
    ┌─────────────────┐           ┌─────────────────┐
    │                 │           │                 │
    │   fulfilled     │           │    rejected     │
    │   (已完成)       │           │    (已失败)     │
    │                 │           │                 │
    └─────────────────┘           └─────────────────┘
              │                             │
              └──────────────┬──────────────┘
                             │
                             ↓
                    ┌─────────────────┐
                    │                 │
                    │    settled      │
                    │   (已敲定)       │
                    │                 │
                    └─────────────────┘

    ⚠️ 状态一旦改变，就不可逆转！
```

### 🎯 Promise 解决的三个问题

| 问题 | 说明 |
|------|------|
| **回调地狱** | 代码难以维护，常常第一个的函数的输出是第二个函数的输入这种现象 |
| **并发请求** | Promise 可以支持多个并发的请求，获取并发请求中的数据 |
| **异步问题** | 这个 Promise 可以解决异步的问题，本身不能说 Promise 是异步的 |

---

## Promise 基本用法

### 📐 基本结构

```javascript
// 构造 Promise 实例，然后调用 .then.then.then 的编写代码方式，就是 Promise

let p = new Promise((resolve, reject) => {    // 调用了 Promise 构造函数
    // 做一些事情
    // 然后在某些条件下 resolve，或者 reject
    if (/* 条件随便写^_^ */) {
        resolve()
    } else {
        reject()
    }
})

p.then(() => {                                 // 调用了 promise 实例的 .then 方法
    // 如果 p 的状态被 resolve 了，就进入这里
}, () => {
    // 如果 p 的状态被 reject
})
```

### 📐 执行流程图解

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Promise 执行流程                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   new Promise((resolve, reject) => {                                │
│       │                                                             │
│       │  执行器函数（同步执行）                                       │
│       │                                                             │
│       ├──→ resolve(value)  ──→  状态变为 fulfilled                  │
│       │                              │                              │
│       │                              ↓                              │
│       │                        .then(onFulfilled)                   │
│       │                                                             │
│       └──→ reject(reason)  ──→  状态变为 rejected                   │
│                                      │                              │
│                                      ↓                              │
│                                .then(_, onRejected)                 │
│                                      或                             │
│                                .catch(onRejected)                   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 📝 声明一个 Promise 对象

```javascript
new Promise((resolve, reject) => {    // 这两个方法主要是用来修改状态的
    console.log("开始求婚。")
    console.log("。。。。。")
    console.log("考虑一下。")
    setTimeout(() => {
        if (isHandsome || isRich) { // 当我们调用 resolve 函数的时候，Promise 的状态就变成 resolved
            resolve('我同意！')
        } else { // 当我们调用 reject 函数的时候，Promise 的状态就变成 reject
            reject("拒绝：我们八字不合")
        }
    }, 2000)
})
// 如果一个 promise 已经被兑现 (resolved) 或被拒绝 (rejected)，那么我们也可以说它处于已敲定 (settled) 状态。
```

---

## 实例方法详解

### 1️⃣ Promise.prototype.then()

#### 💡 作用

**已成功 resolved 的回调和已失败 rejected 的回调**

#### 📝 语法

```javascript
// 调用 Promise 对象的 then 方法，两个参数为函数
p.then(function(value) { // 成功
    console.log(value);
}, function(reason) { // 失败
    console.log(reason);
});
```

#### 📝 链式调用示例

```javascript
getNumber()
.then(function(data){
    console.log('resolved');
    console.log(data);
})
.catch(function(reason){
    console.log('rejected');
    console.log(reason);
});
```

---

### 2️⃣ Promise.prototype.catch()

#### 💡 作用

**catch() 的作用是捕获 Promise 的错误**

其实它和 then 的第二个参数一样，用来**指定 reject 的回调**

#### 📐 catch 的额外能力

```
┌─────────────────────────────────────────────────────────────────┐
│                     catch 的特殊作用                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   在执行 resolve 的回调（也就是上面 then 中的第一个参数）时，       │
│   如果抛出异常了（代码出错了），那么并不会报错卡死 js，            │
│   而是会进到这个 catch 方法中。                                   │
│                                                                 │
│   这是 catch 相比 then 第二个参数的优势！                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 📝 代码示例

```javascript
promise.then(
    () => { console.log('this is success callback') }
).catch(
    (err) => { console.log(err) }
)

// 效果和写在 then 的第二个参数里面一样
// 但 catch 还能捕获 then 中的异常！
```

#### 📝 捕获 then 中的异常

```javascript
getNumber()
.then(function(data){
    console.log('resolved');
    console.log(data);
    console.log(somedata);   // 此处的 somedata 未定义
})
.catch(function(reason){
    console.log('rejected');
    console.log(reason);     // 会捕获到 ReferenceError
});
```

---

### 3️⃣ Promise.prototype.finally()

#### 💡 作用

**finally 方法用于指定无论 Promise 对象的最终状态如何，都将执行 finally。**

#### 🔑 关键特性

- Finally **不接受参数**
- Finally **独立于先前的执行状态**，不依赖于先前的运行结果

#### 📝 代码示例

```javascript
const promise4 = new Promise((resolve, reject) => {
    console.log(x + 1);  // 会报错
});

promise4
    .then(() => {
        console.log("你好");
    })
    .catch((err) => {
        console.log(err);
    })
    .finally(() => {
        console.log("finally");  // 无论如何都会执行
    });
```

#### 📐 finally 执行时机

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   Promise                                                       │
│      │                                                          │
│      ├──→ then() ──→ 成功处理                                   │
│      │                  │                                       │
│      │                  ↓                                       │
│      │              finally() ← 一定执行                         │
│      │                                                          │
│      └──→ catch() ──→ 失败处理                                  │
│                         │                                       │
│                         ↓                                       │
│                     finally() ← 一定执行                         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 静态方法详解

### 1️⃣ Promise.all()

#### 💡 作用

**并行执行多个异步操作，并且在一个回调中处理所有的返回数据。**

> 「谁跑的慢，以谁为准执行回调」

#### 📐 原理图解

```
┌─────────────────────────────────────────────────────────────────┐
│                      Promise.all() 原理                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Promise.all([p1, p2, p3])                                     │
│                                                                 │
│   ┌────────┐    ┌────────┐    ┌────────┐                        │
│   │   p1   │    │   p2   │    │   p3   │                        │
│   │ 1000ms │    │ 2000ms │    │ 1500ms │                        │
│   └────┬───┘    └────┬───┘    └────┬───┘                        │
│        │             │             │                            │
│        ↓             ↓             ↓                            │
│      完成          完成           完成                            │
│        │             │             │                            │
│        └─────────────┼─────────────┘                            │
│                      │                                          │
│                      ↓ 等待全部完成（2000ms）                     │
│               ┌──────────────┐                                  │
│               │  .then()     │                                  │
│               │  [r1,r2,r3]  │  ← 结果按顺序排列                 │
│               └──────────────┘                                  │
│                                                                 │
│   ⚠️ 只要有一个失败，整体就失败！                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 📝 基本用法

```javascript
Promise
.all([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);  // [result1, result2, result3]
});
```

#### 📝 手撕 Promise.all

```javascript
const myPromiseAll = (arr) => {
    let result = [];
    let count = 0;  // 使用计数器更安全
    return new Promise((resolve, reject) => {
        for (let i = 0; i < arr.length; i++) {
            Promise.resolve(arr[i]).then(data => {
                result[i] = data;  // 保证顺序
                count++;
                if (count === arr.length) {  // 所有的都成功才执行成功的回调
                    resolve(result);
                }
            }, reject);  // 有一个失败则执行失败的回调
        }
    });
}
```

---

### 2️⃣ Promise.race()

#### 💡 作用

> 「谁跑的快，以谁为准执行回调」

- 1 秒后 runAsync1 已经执行完了，此时 then 里面的就执行了
- 在 then 里面的回调开始执行时，runAsync2() 和 runAsync3() 并没有停止，仍旧再执行
- 于是再过 1 秒后，输出了他们结束的标志

#### 📐 原理图解

```
┌─────────────────────────────────────────────────────────────────┐
│                     Promise.race() 原理                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Promise.race([p1, p2, p3])                                    │
│                                                                 │
│   ┌────────┐    ┌────────┐    ┌────────┐                        │
│   │   p1   │    │   p2   │    │   p3   │                        │
│   │ 1000ms │    │ 2000ms │    │ 1500ms │                        │
│   └────┬───┘    └────┬───┘    └────┬───┘                        │
│        │             │             │                            │
│        ↓ 最先完成！   │             │                            │
│      完成            │             │                            │
│        │             │             │                            │
│        ↓             │             │                            │
│   ┌──────────────┐   │             │                            │
│   │  .then()     │   │             │                            │
│   │  result1     │   │             │                            │
│   └──────────────┘   │             │                            │
│                      ↓             ↓                            │
│                   (继续执行，但不影响结果)                        │
│                                                                 │
│   🏆 第一个完成的决定最终状态！                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 📝 实用场景：请求超时控制

```javascript
// 请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
            resolve(img);
        }
        img.src = 'xxxxxx';
    });
    return p;
}

// 延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);  // 超时会输出：图片请求超时
});
```

#### 📝 手撕 Promise.race

```javascript
function promiseRace(promises) {
    if (!Array.isArray(promises)) {
        throw new Error("promises must be an array")
    }
    return new Promise(function (resolve, reject) {
        promises.forEach(p =>
            Promise.resolve(p).then(data => {
                resolve(data)      // 第一个成功就 resolve
            }, err => {
                reject(err)        // 第一个失败就 reject
            })
        )
    })
}
```

---

### 3️⃣ Promise.any()

#### 💡 作用

**any() 方法接受一组 promise 作为参数，并将它们打包到新的 promise 对象中。只要一个参数实例处于成功状态，新的 promise 就处于成功状态。参数实例均处于拒绝状态，新承诺处于拒绝状态。**

#### 📐 与 all/race 的对比

```
┌─────────────────────────────────────────────────────────────────┐
│                    Promise 静态方法对比                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   Promise.all()                                                 │
│   ├─ 全部成功 → 成功（返回所有结果数组）                          │
│   └─ 任一失败 → 失败                                            │
│                                                                 │
│   Promise.race()                                                │
│   ├─ 第一个成功 → 成功                                          │
│   └─ 第一个失败 → 失败                                          │
│   （谁快听谁的，不管成功失败）                                    │
│                                                                 │
│   Promise.any()                                                 │
│   ├─ 任一成功 → 成功（返回第一个成功的值）                        │
│   └─ 全部失败 → 失败（AggregateError）                          │
│   （乐观派：只要有一个成功就行）                                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

#### 📝 基本用法

```javascript
Promise.any(promises).then(
    (first) => {
        // Any of the promises was fulfilled.
    },
    (error) => {
        // All of the promises were rejected.
    }
);
```

#### 📝 手撕 Promise.any

```javascript
function myPromiseAny(arr) {
    if (!Array.isArray(arr)) {
        throw new Error('arguments must be a array');
    }
    let rejectCount = 0;
    return new Promise((resolve, reject) => {
        for (let i = 0; i < arr.length; i++) {
            Promise.resolve(arr[i]).then(data => {
                resolve(data);  // 任一成功就 resolve
            }, () => {
                rejectCount++;
                if (rejectCount === arr.length) {
                    reject(new AggregateError('All promises were rejected'));
                }
            });
        }
    });
}
```

---

## 手撕代码大全

### 📋 完整手撕代码汇总

#### 🔥 手撕 Promise.all

```javascript
function myPromiseAll(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('promises must be an array'));
        }
        
        const result = [];
        let count = 0;
        const len = promises.length;
        
        if (len === 0) {
            return resolve([]);
        }
        
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(
                value => {
                    result[index] = value;  // 保证顺序
                    count++;
                    if (count === len) {
                        resolve(result);
                    }
                },
                reason => {
                    reject(reason);  // 任一失败立即 reject
                }
            );
        });
    });
}
```

#### 🔥 手撕 Promise.race

```javascript
function myPromiseRace(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('promises must be an array'));
        }
        
        promises.forEach(promise => {
            Promise.resolve(promise).then(resolve, reject);
        });
    });
}
```

#### 🔥 手撕 Promise.any

```javascript
function myPromiseAny(promises) {
    return new Promise((resolve, reject) => {
        if (!Array.isArray(promises)) {
            return reject(new TypeError('promises must be an array'));
        }
        
        const errors = [];
        let count = 0;
        const len = promises.length;
        
        if (len === 0) {
            return reject(new AggregateError([], 'All promises were rejected'));
        }
        
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(
                value => {
                    resolve(value);  // 任一成功立即 resolve
                },
                reason => {
                    errors[index] = reason;
                    count++;
                    if (count === len) {
                        reject(new AggregateError(errors, 'All promises were rejected'));
                    }
                }
            );
        });
    });
}
```

#### 🔥 手撕 Promise.allSettled

```javascript
function myPromiseAllSettled(promises) {
    return new Promise((resolve) => {
        if (!Array.isArray(promises)) {
            return resolve([]);
        }
        
        const result = [];
        let count = 0;
        const len = promises.length;
        
        if (len === 0) {
            return resolve([]);
        }
        
        promises.forEach((promise, index) => {
            Promise.resolve(promise).then(
                value => {
                    result[index] = { status: 'fulfilled', value };
                    count++;
                    if (count === len) resolve(result);
                },
                reason => {
                    result[index] = { status: 'rejected', reason };
                    count++;
                    if (count === len) resolve(result);
                }
            );
        });
    });
}
```

---

## 方法速查表

```
┌────────────────────────────────────────────────────────────────────────┐
│                        Promise 方法速查表                               │
├──────────────────┬─────────────────────────────────────────────────────┤
│      方法         │                    说明                             │
├──────────────────┼─────────────────────────────────────────────────────┤
│  .then()         │  处理 fulfilled 和 rejected 状态                     │
├──────────────────┼─────────────────────────────────────────────────────┤
│  .catch()        │  捕获错误，等同于 .then(null, onRejected)            │
│                  │  额外能力：捕获 then 中的异常                         │
├──────────────────┼─────────────────────────────────────────────────────┤
│  .finally()      │  无论状态如何都执行，不接受参数                        │
├──────────────────┼─────────────────────────────────────────────────────┤
│  Promise.all()   │  全部成功才成功，任一失败就失败                        │
│                  │  「谁跑的慢，以谁为准」                               │
├──────────────────┼─────────────────────────────────────────────────────┤
│  Promise.race()  │  第一个敲定的决定结果（不管成功失败）                  │
│                  │  「谁跑的快，以谁为准」                               │
├──────────────────┼─────────────────────────────────────────────────────┤
│  Promise.any()   │  任一成功就成功，全部失败才失败                        │
│                  │  「乐观派：只要有希望就行」                            │
├──────────────────┼─────────────────────────────────────────────────────┤
│Promise.allSettled│  等待所有 Promise 敲定，返回每个的状态和结果          │
│                  │  「稳重派：不急，等大家都完事」                        │
└──────────────────┴─────────────────────────────────────────────────────┘
```

---

## 核心奥义

```
╔═══════════════════════════════════════════════════════════════════════╗
║                                                                       ║
║   🎯 一句话总结：                                                      ║
║                                                                       ║
║   Promise 是异步编程的优雅解法，三态流转不可逆；                          ║
║   then 接成功，catch 捕异常，finally 善后不挑拣；                        ║
║   all 等全员，race 看冠军，any 求一胜，掌握手撕横扫面试关！               ║
║                                                                       ║
╚═══════════════════════════════════════════════════════════════════════╝
```

---

## 📋 速记卡片

```
┌─────────────────────────────────────────────────────────────────┐
│                     Promise 核心速记                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【三种状态】                                                    │
│   pending → fulfilled (resolve触发)                             │
│   pending → rejected  (reject触发)                              │
│   ⚠️ 状态不可逆！                                                │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【基本用法】                                                    │
│   new Promise((resolve, reject) => { ... })                     │
│   .then(onFulfilled, onRejected)                                │
│   .catch(onRejected)                                            │
│   .finally(onFinally)                                           │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【静态方法口诀】                                                 │
│   all  - 全成功才成功（AND 逻辑）                                │
│   race - 谁快听谁的（竞速）                                      │
│   any  - 有一个成功就行（OR 逻辑）                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---
