# bind、apply、call 的用法 - 第一性原理完全指南

> 🎯 **面试高频指数：★★★★★**

---

## 📚 目录

1. [第一性原理：为什么需要改变 this？](#第一性原理为什么需要改变-this)
2. [三者的相同点和不同点](#三者的相同点和不同点)
3. [call 的用法](#call-的用法)
4. [apply 的用法](#apply-的用法)
5. [bind 的用法](#bind-的用法)
6. [手撕代码大全](#手撕代码大全)
7. [核心奥义](#核心奥义)

---

## 第一性原理：为什么需要改变 this？

### 🧠 本质思考

**this 的本质 = 函数执行时的上下文对象**

```
┌─────────────────────────────────────────────────────────────────┐
│                      this 指向问题                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   JavaScript 中，this 的指向是动态的，取决于函数的调用方式         │
│                                                                 │
│   问题场景：                                                     │
│   ┌─────────────────────────────────────────┐                   │
│   │  const obj = {                          │                   │
│   │      name: 'xiaoming',                  │                   │
│   │      sayHello: function() {             │                   │
│   │          console.log(this.name)         │                   │
│   │      }                                  │                   │
│   │  }                                      │                   │
│   │                                         │                   │
│   │  obj.sayHello()  // 'xiaoming' ✓        │                   │
│   │                                         │                   │
│   │  const fn = obj.sayHello                │                   │
│   │  fn()  // undefined ✗  this 丢失了！     │                   │
│   └─────────────────────────────────────────┘                   │
│                                                                 │
│   解决方案：使用 call / apply / bind 手动指定 this               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 🎯 三个方法的核心作用

```
╔═══════════════════════════════════════════════════════════════════╗
║                                                                   ║
║   call、apply、bind 的核心作用：                                   ║
║                                                                   ║
║   【改变函数执行时 this 的指向】                                    ║
║                                                                   ║
║   让一个对象"借用"另一个对象的方法                                  ║
║                                                                   ║
╚═══════════════════════════════════════════════════════════════════╝
```

---

## 三者的相同点和不同点

### ✅ 相同点

| 序号 | 相同点 |
|------|--------|
| 1 | 三个都是用于**改变 this 指向** |
| 2 | 接收的**第一个参数都是 this 要指向的对象** |
| 3 | 都可以利用**后续参数传参** |

### ❌ 不同点

| 序号 | 不同点 |
|------|--------|
| 1 | call 和 bind 传参相同，**多个参数依次传入**的 |
| 2 | apply 只有两个参数，**第二个参数为数组** |
| 3 | call 和 apply 都是对函数进行**直接调用**，而 bind 方法**不会立即调用函数**，而是返回一个修改 this 后的函数 |

### 📐 核心区别图解

```
┌─────────────────────────────────────────────────────────────────────┐
│                    call vs apply vs bind 对比                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   【调用语法】                                                       │
│                                                                     │
│   fn.call(thisArg, arg1, arg2, arg3, ...)                          │
│                    └─────────────────────┘                          │
│                         参数依次传入                                 │
│                                                                     │
│   fn.apply(thisArg, [arg1, arg2, arg3])                            │
│                     └─────────────────┘                             │
│                        参数为数组                                    │
│                                                                     │
│   fn.bind(thisArg, arg1, arg2, arg3, ...)()                        │
│                    └─────────────────────┘ ↑                        │
│                         参数依次传入        │                        │
│                                           需要再调用一次             │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   【执行时机】                                                       │
│                                                                     │
│   call   ──→  立即执行 ✓                                            │
│   apply  ──→  立即执行 ✓                                            │
│   bind   ──→  返回新函数，需要手动调用才执行                          │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   【记忆口诀】                                                       │
│                                                                     │
│   call  - "C" all 参数，依次 Call（打电话，一个一个说）               │
│   apply - "A" rray 数组，Apply（申请，打包一起交）                   │
│   bind  - "B" ind 绑定，返回新函数（绑定好，等你用）                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## call 的用法

### 💡 语法

```javascript
fn.call(thisArg, arg1, arg2, arg3, ...)
```

**调用 fn.call 时会将 fn 中的 this 指向修改为传入的第一个参数 thisArg；将后面的参数传入给 fn，并立即执行函数 fn。**

### 📝 代码示例

```javascript
let obj = {
    name: "xiaoming",
    age: 24,
    sayHello: function (job, hobby) {
        console.log(`我叫${this.name},今年${this.age}岁。我的工作是：${job}, 我的爱好是：${hobby}。`)
    }
}

obj.sayHello('程序员', '看美女'); 
// 我叫xiaoming,今年24岁。我的工作是：程序员, 我的爱好是：看美女。

let obj1 = {
    name: "lihua",
    age: 30
}

// obj1.sayHello(); // Uncaught TypeError: obj1.sayHello is not a function

// 使用 call 借用 obj 的方法，并改变 this 指向
obj.sayHello.call(obj1, '设计师', '画画'); 
// 我叫lihua,今年30岁。我的工作是：设计师, 我的爱好是：画画。
```

### 📐 执行过程图解

```
┌─────────────────────────────────────────────────────────────────┐
│                    call 执行过程                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   obj.sayHello.call(obj1, '设计师', '画画')                      │
│        │           │        │         │                         │
│        │           │        └─────────┴── 后续参数传给 sayHello  │
│        │           │                                            │
│        │           └── this 指向 obj1                           │
│        │                                                        │
│        └── 原函数                                                │
│                                                                 │
│   执行步骤：                                                     │
│   ┌────────────────────────────────────────────────────────┐    │
│   │ 1. 将 sayHello 的 this 从 obj 改为 obj1                 │    │
│   │ 2. 将 '设计师', '画画' 作为参数传入                      │    │
│   │ 3. 立即执行 sayHello 函数                               │    │
│   └────────────────────────────────────────────────────────┘    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## apply 的用法

### 💡 语法

```javascript
fn.apply(thisArg, [argsArr])
```

**fn.apply 的作用和 call 相同：修改 this 指向，并立即执行 fn。区别在于传参形式不同，apply 接受两个参数，第一个参数是要指向的 this 对象，第二个参数是一个数组，数组里面的元素会被展开传入 fn，作为 fn 的参数。**

### 📝 代码示例

```javascript
let obj = {
    name: "xiaoming",
    age: 24,
    sayHello: function (job, hobby) {
        console.log(`我叫${this.name},今年${this.age}岁。我的工作是：${job}, 我的爱好是：${hobby}。`)
    }
}

obj.sayHello('程序员', '看美女'); 
// 我叫xiaoming,今年24岁。我的工作是：程序员, 我的爱好是：看美女。

let obj1 = {
    name: "lihua",
    age: 30
}

// 使用 apply，第二个参数为数组
obj.sayHello.apply(obj1, ['设计师', '画画']); 
// 我叫lihua,今年30岁。我的工作是：设计师, 我的爱好是：画画。
```

### 📐 call vs apply 传参对比

```
┌─────────────────────────────────────────────────────────────────┐
│                    call vs apply 传参对比                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【call 传参】                                                  │
│   fn.call(thisArg, arg1, arg2, arg3)                           │
│                    │     │     │                                │
│                    └─────┴─────┴── 参数一个一个传                │
│                                                                 │
│   【apply 传参】                                                 │
│   fn.apply(thisArg, [arg1, arg2, arg3])                        │
│                     └────────────────┘                          │
│                          数组形式                                │
│                             │                                   │
│                             ↓                                   │
│                     展开后传给函数                                │
│                                                                 │
│   【实际应用场景】                                                │
│                                                                 │
│   // 求数组最大值 - apply 的经典用法                              │
│   Math.max.apply(null, [1, 2, 3, 4, 5])  // 5                   │
│                                                                 │
│   // ES6 后可以用展开运算符替代                                   │
│   Math.max(...[1, 2, 3, 4, 5])  // 5                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## bind 的用法

### 💡 语法

```javascript
fn.bind(thisArg, arg1, arg2, arg3, ...)
```

**fn.bind 的作用是只修改 this 指向，但不会立即执行 fn；会返回一个修改了 this 指向后的 fn。需要调用才会执行：`bind(thisArg, arg1, arg2, arg3, ...)()`。bind 的传参和 call 相同。**

### 📝 代码示例

```javascript
let obj = {
    name: "xiaoming",
    age: 24,
    sayHello: function (job, hobby) {
        console.log(`我叫${this.name},今年${this.age}岁。我的工作是：${job}, 我的爱好是：${hobby}。`)
    }
}

let obj1 = {
    name: "lihua",
    age: 30
}

// bind 返回一个新函数，不会立即执行
const boundFn = obj.sayHello.bind(obj1, '设计师', '画画');

// 需要手动调用
boundFn();  // 我叫lihua,今年30岁。我的工作是：设计师, 我的爱好是：画画。

// 或者直接链式调用
obj.sayHello.bind(obj1, '设计师', '画画')();
```

### 📐 bind 的特殊之处

```
┌─────────────────────────────────────────────────────────────────┐
│                       bind 的特殊之处                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   【返回新函数】                                                  │
│                                                                 │
│   const boundFn = fn.bind(obj)                                  │
│                          │                                      │
│                          ↓                                      │
│                   ┌──────────────┐                              │
│                   │   新函数      │                              │
│                   │   this → obj │                              │
│                   └──────────────┘                              │
│                          │                                      │
│                          ↓                                      │
│                   boundFn()  // 调用时执行                       │
│                                                                 │
│   【柯里化传参】                                                  │
│                                                                 │
│   function sum(a, b, c) { return a + b + c }                    │
│                                                                 │
│   // 可以分次传参                                                │
│   const fn1 = sum.bind(null, 1)      // 预设 a = 1              │
│   const fn2 = fn1.bind(null, 2)      // 预设 b = 2              │
│   fn2(3)  // 6                       // 传入 c = 3              │
│                                                                 │
│   【作为构造函数时的特殊行为】                                    │
│                                                                 │
│   当 bind 返回的函数作为构造函数使用时（使用 new 调用）            │
│   bind 时绑定的 this 会被忽略！                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 手撕代码大全

### 🔥 手撕 call

```javascript
Function.prototype.myCall = function (context, ...args) {
    // 如果没有提供 context，默认为全局对象（在浏览器中为 window）
    context = context || globalThis;
    
    // 创建一个唯一的符号属性，防止与上下文中的其他属性冲突
    const fnSymbol = Symbol();
    
    // 将函数作为上下文对象的属性
    context[fnSymbol] = this;
    
    // 使用上下文对象调用该函数，并传递参数
    const result = context[fnSymbol](...args);
    
    // 删除该属性
    delete context[fnSymbol];
    
    // 返回函数调用结果
    return result;
};

// 使用示例
function sum(a, b) {
    return this.v + a + b;
}
sum.myCall({v: 1}, 2, 3);  // 6
```

### 📐 手撕 call 原理图解

```
┌─────────────────────────────────────────────────────────────────┐
│                    手撕 call 原理                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   fn.myCall(obj, arg1, arg2)                                    │
│                                                                 │
│   执行步骤：                                                     │
│                                                                 │
│   Step 1: 将 fn 挂载到 obj 上                                    │
│   ┌────────────────────┐                                        │
│   │  obj = {           │                                        │
│   │      ...原有属性,   │                                        │
│   │      [Symbol]: fn  │ ← 临时挂载                              │
│   │  }                 │                                        │
│   └────────────────────┘                                        │
│                                                                 │
│   Step 2: 通过 obj 调用 fn                                       │
│   ┌────────────────────┐                                        │
│   │  obj[Symbol](args) │ ← 此时 fn 内部的 this 就是 obj          │
│   └────────────────────┘                                        │
│                                                                 │
│   Step 3: 删除临时属性，返回结果                                  │
│   ┌────────────────────┐                                        │
│   │  delete obj[Symbol]│                                        │
│   │  return result     │                                        │
│   └────────────────────┘                                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 🔥 手撕 apply

```javascript
Function.prototype.myApply = function(_this, args = []) {
    // 处理 null/undefined 的情况
    if (!_this) _this = Object.create(null);
    
    // 将函数挂载到目标对象上
    _this.fn = this;
    
    // 展开数组参数，调用函数
    const res = _this.fn(...args);
    
    // 删除临时属性
    delete _this.fn;
    
    // 返回结果
    return res;
}

// 使用示例
function sum(a, b) {
    return this.v + a + b;
}
sum.myApply({v: 1}, [2, 3]);  // 6
```

### 📝 手撕 apply 要点

- 第一参数接收 this 对象
- 改变 this 指向：将函数作为传入 this 对象的方法
- 第二个参数默认数组
- 展开语法，支持调用参数列表
- 调用并删除方法，返回结果

### 🔥 手撕 bind

```javascript
Function.prototype.myBind = function(_this, ...args) {
    // 保存原函数
    const fn = this;
    
    // 返回新函数
    return function F(...args2) {
        // 判断是否作为构造函数调用
        return this instanceof F 
            ? new fn(...args, ...args2)           // 作为构造函数：忽略 myBind 绑定的 this
            : fn.apply(_this, args.concat(args2)) // 普通调用：使用绑定的 this
    }
}

// 使用示例
function Sum(a, b) {
    this.v = (this.v || 0) + a + b;
    return this;
}

const NewSum = Sum.myBind({v: 1}, 2);
NewSum(3);           // 调用：{v: 6}
new NewSum(3);       // 构造函数：{v: 5}  忽略 myBind 绑定的 this
```

### 📐 手撕 bind 要点

```
┌─────────────────────────────────────────────────────────────────┐
│                    手撕 bind 要点                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   1. 第一个参数接收 this 对象                                    │
│                                                                 │
│   2. 返回函数，根据使用方式判断：                                 │
│      ├── 普通调用：使用 apply 绑定 this                          │
│      └── 构造函数调用（new）：忽略绑定的 this                     │
│                                                                 │
│   3. 支持柯里化传参：                                            │
│      ├── bind 时传入的参数                                       │
│      └── 调用时传入的参数                                        │
│      两者合并后传给原函数                                         │
│                                                                 │
│   【判断是否作为构造函数】                                        │
│   this instanceof F                                             │
│   ├── true  → new 调用，this 是新创建的实例                      │
│   └── false → 普通调用，this 是全局或其他对象                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 完整对比速查表

```
┌────────────────────────────────────────────────────────────────────────┐
│                      call / apply / bind 速查表                         │
├──────────────┬──────────────────┬──────────────────┬───────────────────┤
│              │       call       │      apply       │       bind        │
├──────────────┼──────────────────┼──────────────────┼───────────────────┤
│   语法       │ fn.call(this,    │ fn.apply(this,   │ fn.bind(this,     │
│              │   a, b, c)       │   [a, b, c])     │   a, b, c)        │
├──────────────┼──────────────────┼──────────────────┼───────────────────┤
│   传参方式   │ 依次传入          │ 数组形式          │ 依次传入          │
├──────────────┼──────────────────┼──────────────────┼───────────────────┤
│   执行时机   │ 立即执行          │ 立即执行          │ 返回新函数        │
│              │                  │                  │ 需手动调用        │
├──────────────┼──────────────────┼──────────────────┼───────────────────┤
│   返回值     │ 函数执行结果      │ 函数执行结果      │ 绑定后的新函数    │
├──────────────┼──────────────────┼──────────────────┼───────────────────┤
│   使用场景   │ 借用方法          │ 借用方法          │ 事件绑定          │
│              │ 继承              │ 数组操作          │ 定时器            │
│              │                  │ Math.max         │ 柯里化            │
└──────────────┴──────────────────┴──────────────────┴───────────────────┘
```

---

## 核心奥义

```
╔═══════════════════════════════════════════════════════════════════════╗
║                                                                       ║
║   🎯 一句话总结：                                                      ║
║                                                                       ║
║   call、apply、bind 三兄弟，都是 this 指向的搬运工；                    ║
║   call 一个个传，apply 打包传，两者立即执行不等闲；                      ║
║   bind 最特别，返回新函数慢慢来，new 调用时绑定全作废！                  ║
║                                                                       ║
╚═══════════════════════════════════════════════════════════════════════╝
```

---

## 📋 速记卡片

```
┌─────────────────────────────────────────────────────────────────┐
│                  call / apply / bind 速记                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【相同点】                                                      │
│   ✓ 都改变 this 指向                                            │
│   ✓ 第一个参数都是目标 this                                      │
│   ✓ 都能传递参数                                                 │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【不同点】                                                      │
│   call   → 参数依次传，立即执行                                  │
│   apply  → 参数数组传，立即执行                                  │
│   bind   → 参数依次传，返回新函数                                │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  【手撕核心】                                                    │
│   1. 将函数挂载到目标对象上                                      │
│   2. 通过对象调用函数（this 自动指向对象）                        │
│   3. 删除临时属性，返回结果                                      │
│                                                                 │
│  【bind 特殊】                                                   │
│   返回新函数 + 处理 new 调用的情况                               │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

> 📝 **作者提示**：手撕 call/apply/bind 是面试必考题，务必掌握原理！