## 第一性原理拆解：JavaScript 函数

### 核心问题：如何控制代码的执行上下文、时机和复用？

---

## 一、闭包（Closure）

### 本质：函数 + 它能访问的外部变量

```javascript
function outer() {
    let count = 0;  // 外部变量
    return function inner() {  // 内部函数
        return ++count;
    }
}

let fn = outer();
fn();  // 1
fn();  // 2  ← count 没有被销毁！
```

### 为什么会这样？

```
┌─────────────────────────────────────────────────┐
│  正常情况：函数执行完 → 局部变量销毁            │
│  闭包情况：内部函数引用外部变量 → 变量被保留    │
└─────────────────────────────────────────────────┘
```

### 闭包的应用

```javascript
// 1. 模拟私有变量
function Counter() {
    let count = 0;  // 私有，外部无法直接访问
    return {
        get: () => count,
        increment: () => ++count
    };
}

// 2. 解决循环问题（经典面试题）
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);  // 3, 3, 3
}

// 用闭包解决
for (var i = 0; i < 3; i++) {
    (function(j) {
        setTimeout(() => console.log(j), 100);  // 0, 1, 2
    })(i);
}

// 或者直接用 let
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);  // 0, 1, 2
}
```

---

## 二、this 指向

### 核心规则：this 由调用方式决定，不是定义位置

| 调用方式 | this 指向 | 示例 |
|---------|----------|------|
| 普通调用 | window（严格模式 undefined） | `fn()` |
| 对象方法 | 调用的对象 | `obj.fn()` |
| 构造函数 | 新创建的实例 | `new Fn()` |
| call/apply/bind | 指定的对象 | `fn.call(obj)` |
| 箭头函数 | 定义时的外层 this | `() => {}` |

### 经典面试题

```javascript
var name = "window";

var obj = {
    name: "obj",
    foo: function() {
        console.log(this.name);
    },
    bar: () => {
        console.log(this.name);
    }
};

obj.foo();           // "obj"（对象调用）
obj.bar();           // "window"（箭头函数，继承外层 this）

let fn = obj.foo;
fn();                // "window"（普通调用）

obj.foo.call({name: "custom"});  // "custom"（call 指定）
```

---

## 三、call / apply / bind

### 本质：改变函数的 this 指向

| 方法 | 参数形式 | 是否立即执行 |
|------|---------|------------|
| call | 逐个传入 | ✅ 立即执行 |
| apply | 数组传入 | ✅ 立即执行 |
| bind | 逐个传入 | ❌ 返回新函数 |

### 经典面试代码：手写实现

```javascript
// 手写 call
Function.prototype.myCall = function(context, ...args) {
    context = context ?? window;
    context = Object(context);  // 处理原始类型
    
    const key = Symbol('fn');
    context[key] = this;
    
    const result = context[key](...args);
    delete context[key];
    
    return result;
};

// 手写 apply
Function.prototype.myApply = function(context, args = []) {
    context = context ?? window;
    context = Object(context);
    
    const key = Symbol('fn');
    context[key] = this;
    
    const result = context[key](...args);
    delete context[key];
    
    return result;
};

// 手写 bind
Function.prototype.myBind = function(context, ...args) {
    const self = this;
    
    const bound = function(...innerArgs) {
        // 处理 new 调用的情况
        return self.apply(
            this instanceof bound ? this : context,
            args.concat(innerArgs)
        );
    };
    
    // 维护原型链
    bound.prototype = Object.create(self.prototype);
    return bound;
};
```

---

## 四、箭头函数

### 与普通函数的区别

| 特性 | 普通函数 | 箭头函数 |
|------|---------|---------|
| this | 调用时确定 | 定义时继承外层 |
| arguments | ✅ 有 | ❌ 没有 |
| 作为构造函数 | ✅ 可以 new | ❌ 不能 new |
| prototype | ✅ 有 | ❌ 没有 |

### 关键点：箭头函数的 this 无法被改变

```javascript
const obj = { name: "obj" };

const arrow = () => console.log(this.name);
arrow.call(obj);  // 还是 window，call 无效！

const normal = function() { console.log(this.name); };
normal.call(obj);  // "obj"，call 有效
```

---

## 五、类数组转数组

### 什么是类数组？

有 `length` 属性，可用索引访问，但**不是真正的数组**。

常见类数组：`arguments`、`NodeList`、`HTMLCollection`

### 转换方法

```javascript
// 1. 扩展运算符（推荐）
[...arguments]

// 2. Array.from（推荐）
Array.from(arguments)

// 3. slice
Array.prototype.slice.call(arguments)
[].slice.call(arguments)
```

---

## 六、IIFE（立即调用函数表达式）

### 本质：创建独立作用域，防止变量污染全局

```javascript
(function() {
    var privateVar = "私有";
    // 外部访问不到 privateVar
})();

// 常用于模块化封装
var module = (function() {
    var count = 0;
    return {
        get: () => count,
        increment: () => ++count
    };
})();
```

---

## 七、防抖与节流

### 本质区别

```
防抖（debounce）：等你停下来再执行
节流（throttle）：固定频率执行
```

### 应用场景

| 场景 | 选择 |
|------|------|
| 搜索框输入 | 防抖（停止输入后再搜索） |
| 窗口 resize | 节流（固定频率计算） |
| 按钮点击 | 节流（防止重复提交） |
| 表单验证 | 防抖（输入完再验证） |

### 经典面试代码

```javascript
// 防抖：最后一次触发后 delay 毫秒执行
function debounce(fn, delay = 300) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
}

// 节流：每 delay 毫秒最多执行一次
function throttle(fn, delay = 300) {
    let lastTime = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastTime >= delay) {
            fn.apply(this, args);
            lastTime = now;
        }
    };
}

// 使用
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce(function(e) {
    console.log('搜索：', e.target.value);
}, 500));

window.addEventListener('scroll', throttle(function() {
    console.log('滚动位置：', window.scrollY);
}, 200));
```

### 带立即执行的防抖

```javascript
function debounce(fn, delay = 300, immediate = false) {
    let timer = null;
    return function(...args) {
        const callNow = immediate && !timer;
        
        clearTimeout(timer);
        timer = setTimeout(() => {
            timer = null;
            if (!immediate) fn.apply(this, args);
        }, delay);
        
        if (callNow) fn.apply(this, args);
    };
}
```

---

## 总结

```
┌────────────────────────────────────────────────────────────────┐
│                    JavaScript 函数核心                          │
├────────────────────────────────────────────────────────────────┤
│                                                                │
│  闭包 ─→ 函数 + 外部变量引用 → 变量不被销毁 → 私有变量/缓存    │
│                                                                │
│  this ─→ 调用方式决定                                          │
│         │  普通调用 → window                                   │
│         │  对象方法 → 该对象                                   │
│         │  new 调用 → 新实例                                   │
│         │  call/apply/bind → 指定对象                          │
│         └  箭头函数 → 定义时外层 this（不可改变）              │
│                                                                │
│  call/apply/bind ─→ 改变 this                                  │
│         │  call(ctx, a, b) → 立即执行                          │
│         │  apply(ctx, [a,b]) → 立即执行                        │
│         └  bind(ctx, a) → 返回新函数                           │
│                                                                │
│  箭头函数 ─→ 没有自己的 this/arguments/prototype，不能 new     │
│                                                                │
│  防抖节流 ─→ 控制函数执行频率                                  │
│         │  防抖：停止触发后执行（搜索输入）                    │
│         └  节流：固定频率执行（滚动事件）                      │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

**核心记忆：闭包管作用域，this 看调用，防抖节流控频率。**