# 第一性原理拆解 JavaScript 闭包

## 🧠 第一性原理思维

**不靠类比、不靠记忆，从最基本的事实一步步推导出结论。**

---

## 第一层：三个基本事实

### 事实1：函数可以嵌套
```javascript
function 外() {
    function 内() { }
}
```

### 事实2：内部函数可以访问外部变量
```javascript
function 外() {
    let a = 1;
    function 内() {
        console.log(a);  // ✅ 能访问
    }
}
```

### 事实3：函数可以被返回
```javascript
function 外() {
    function 内() { }
    return 内;  // ✅ 函数当返回值
}
```

---

## 第二层：推导出问题

把三个事实组合起来：

```javascript
function 外() {
    let a = 1;
    function 内() {
        console.log(a);
    }
    return 内;
}

const fn = 外();  // 外() 执行完毕
fn();             // ❓ 此时 a 还在吗？
```

**关键问题**：
- 正常情况：函数执行完 → 局部变量销毁
- 但 `内` 还在引用 `a` → 怎么办？

---

## 第三层：推导出答案

**JavaScript 的选择**：

> 如果有人还在用这个变量，就不销毁它。

```
外() 执行完毕
    ↓
正常应该销毁 a
    ↓
但 内() 还引用着 a
    ↓
所以 a 被保留下来，跟着 内() 走
    ↓
这个「函数 + 它引用的外部变量」的组合 = 闭包
```

---

## 第四层：闭包的本质定义

```
闭包 = 函数 + 它能访问的外部变量环境
```

| 组成部分 | 说明 |
|---------|------|
| 函数本身 | 代码逻辑 |
| 词法环境 | 函数定义时能访问的变量 |

**不是什么神秘的东西，就是 JS 为了让内部函数正常工作，把需要的变量"打包带走"了。**

---

## 第五层：验证理解

### 经典循环问题

```javascript
for (var i = 1; i <= 3; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}
// 输出：4, 4, 4
```

**用第一性原理分析**：
1. `var` → 只有一个 `i`（函数作用域）
2. 三个函数都引用同一个 `i`
3. 循环结束时 `i = 4`
4. 三个函数执行时，去找 `i`，都是 4

### 解决方案

```javascript
for (var i = 1; i <= 3; i++) {
    (function(j) {  // 创建新作用域，j 是独立的
        setTimeout(function() {
            console.log(j);
        }, 1000);
    })(i);
}
// 输出：1, 2, 3
```

**原理**：每次循环创建一个新闭包，各自保存独立的 `j`。

---

## 📌 总结

| 层级 | 内容 |
|-----|------|
| 基本事实 | 函数嵌套 + 内访问外 + 函数可返回 |
| 产生的问题 | 外部函数执行完，变量该不该销毁？ |
| JS的解决方案 | 有人用就不销毁，打包带走 |
| 这个方案的名字 | **闭包** |

> **闭包不是一个"特性"，而是 JS 作用域规则的自然结果。**